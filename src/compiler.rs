// Copyright (c) 2020 Weird Constructor <weirdconstructor@gmail.com>
// This is a part of WLambda. See README.md and COPYING for details.

/*!

  Implements all the semantics of WLambda. It takes an AST
  that was generated by the parser and compiles it to a
  tree of closures.

  The compiler and the runtime require multiple
  other data structures, such as `GlobalEnv` with a
  `SymbolTable` for global functions,
  a `ModuleResolver` and a `ThreadCreator`.

  An to execute the closures that the compiler generated
  you need an `Env` instance (which itself requires a reference
  to the `GlobalEnv`.

  To orchestrate all this the `EvalContext` exists.
  You can customize:

  - The `GlobalEnv` with custom
  globals and even with your own core and standard library functions
  - You can provide a custom `ModuleResolver`, which loads the
  modules from other sources (eg. memory or network).
  - You can make your own `ThreadCreator`, to customize thread
  creation.

  However, to get some WLambda code running quickly there is
  `EvalContext::new_default()` which creates a ready made context for
  evaluating WLambda code:


```
use wlambda::*;

let mut ctx = EvalContext::new_default();
let res = ctx.eval("$[10, 20 + 30]").unwrap();

assert_eq!(res.s(), "$[10,50]");
```

*/

use crate::parser::{self};
use crate::prelude::*;
use crate::vval::VVal;
use crate::vval::Syntax;
use crate::vval::Env;
use crate::vval::VValFun;
use crate::vval::StackAction;
use crate::vval::CompileError;
use crate::vval::VarPos;
use crate::threads::*;
use std::rc::Rc;
use std::sync::Arc;
use std::sync::Mutex;
use std::cell::RefCell;
use std::fmt::{Display, Formatter};

use fnv::FnvHashMap;

#[allow(dead_code)]
#[derive(Debug, Clone, PartialEq)]
struct CompileLocal {
}

#[derive(Debug)]
/// Error for the `ModuleResolver` trait, to implement
/// custom module loading behaviour.
#[allow(dead_code)]
pub enum ModuleLoadError<'a> {
    NoSuchModule(String),
    ModuleEvalError(EvalError),
    Other(&'a str),
}

/// This trait is responsible for loading modules
/// and returning a collection of name->value mappings for a module
/// name.
///
/// See also GlobalEnv::set_resolver() about how to configure the
/// global environment to use you trait implementation.
///
/// There is a default implementation named LocalFileModuleResolver,
/// which loads the modules from files.
pub trait ModuleResolver {
    /// Resolves the path to a HashMap of names -> VVal.
    /// Where you obtain this mapping from is completely up to you.
    /// You can statically define these, load them from a JSON file,
    /// load them by executing another WLambda script or whatever you fancy.
    ///
    /// See LocalFileModuleResolver as example on how to implement this.
    fn resolve(&self, global: GlobalEnvRef, path: &[String], import_file_path: Option<&str>) -> Result<SymbolTable, ModuleLoadError>;
}

/// This structure implements the ModuleResolver trait and is
/// responsible for loading modules on `!@import` for WLambda.
#[derive(Debug, Clone, Default)]
pub struct LocalFileModuleResolver { }

#[allow(dead_code)]
impl LocalFileModuleResolver {
    pub fn new() -> LocalFileModuleResolver {
        LocalFileModuleResolver { }
    }
}

/// Stores symbols and values for a WLambda module that can be added to a `GlobalEnv` with `set_module`.
///
///```
/// use wlambda::{SymbolTable, GlobalEnv, EvalContext, Env};
///
/// let mut st = SymbolTable::new();
///
/// let outbuf = std::rc::Rc::new(std::cell::RefCell::new(String::from("")));
///
/// let captured_outbuf = outbuf.clone();
///
/// st.fun("print", move |e: &mut Env, _argc: usize| {
///     std::mem::replace(&mut *captured_outbuf.borrow_mut(), e.arg(0).s());
///     println!("MY PRINT: {}", e.arg(0).s());
///     Ok(e.arg(0).clone())
/// }, Some(1), Some(1), false);
///
/// let global_env = GlobalEnv::new_default();
/// global_env.borrow_mut().set_module("my", st);
///
/// let mut ctx = EvalContext::new(global_env);
/// ctx.eval("!@import my my; my:print 1337");
///
/// assert_eq!(outbuf.borrow().clone(), "1337");
///```
#[derive(Default, Debug, Clone)]
pub struct SymbolTable {
    symbols: FnvHashMap<String, VVal>,
}

impl SymbolTable {
    pub fn new() -> Self {
        SymbolTable {
            symbols: FnvHashMap::with_capacity_and_hasher(10, Default::default()),
        }
    }

    /// This function returns all symbols defined in this SymbolTable.
    /// It's mainly used for tests.
    #[allow(dead_code)]
    pub fn list(&self) -> std::vec::Vec<String> {
        let mut v = vec![];
        for (s, _) in self.symbols.iter() {
            v.push(s.to_string());
        }
        v
    }

    /// Sets the entry `name` to the `value`. So that the
    /// value can be imported.
    #[allow(dead_code)]
    pub fn set(&mut self, name: &str, value: VVal) {
        self.symbols.insert(String::from(name), value);
    }
    
    /// Retrieves a value from the SymbolTable, if present.
    /// ```
    /// use wlambda::{VVal, EvalContext};
    /// let mut ctx = EvalContext::new_default();
    /// ctx.eval("!@export to_rust = 42.0;");
    ///
    /// assert_eq!(ctx.get_exports().get("to_rust").cloned(), Some(VVal::Flt(42.0)));
    /// ```
    #[allow(dead_code)]
    pub fn get(&mut self, name: &str) -> Option<&VVal> {
        self.symbols.get(name)
    }

    /// Helper function for building symbol tables with functions in them.
    ///
    /// See also `VValFun::new_fun` for more details.
    ///
    ///```
    /// use wlambda::VVal;
    /// let mut st = wlambda::compiler::SymbolTable::new();
    /// st.fun("nothing",
    ///        |e: &mut wlambda::vval::Env, _argc: usize| Ok(VVal::None),
    ///        None, None, false);
    ///```
    pub fn fun<T>(
        &mut self, fnname: &str, fun: T,
        min_args: Option<usize>,
        max_args: Option<usize>,
        err_arg_ok: bool)
        where T: 'static + Fn(&mut Env, usize) -> Result<VVal,StackAction> {

        self.symbols.insert(
            String::from(fnname), VValFun::new_fun(fun, min_args, max_args, err_arg_ok));
    }
}

impl ModuleResolver for LocalFileModuleResolver {
    fn resolve(&self, global: GlobalEnvRef, path: &[String], import_file_path: Option<&str>)
        -> Result<SymbolTable, ModuleLoadError>
    {
        let genv = GlobalEnv::new_empty_default();
        genv.borrow_mut().set_thread_creator(
            global.borrow().get_thread_creator());
        genv.borrow_mut().import_modules_from(&*global.borrow());

        let mut ctx = EvalContext::new(genv);
        let pth = format!("{}.wl", path.join("/"));
        let mut check_paths = vec![pth];

        if let Some(ifp) = import_file_path {
            let impfp = std::path::Path::new(ifp);

            let import_dir_path =
                if impfp.is_file() {
                    impfp.parent()
                } else {
                    Some(impfp)
                };

            if let Some(idp) = import_dir_path {
                let mut pb = idp.to_path_buf();
                for p in path { pb.push(p); }

                if let Some(p) = pb.as_path().to_str() {
                    check_paths.push(format!("{}.wl", p));
                }
            }
        }

        for pth in check_paths.iter() {
            if std::path::Path::new(pth).exists() {
                return match ctx.eval_file(pth) {
                    Err(e) => Err(ModuleLoadError::ModuleEvalError(e)),
                    Ok(_v) => Ok(ctx.get_exports()),
                }
            }
        }

        Err(ModuleLoadError::NoSuchModule(check_paths.join(";")))
    }
}

/// Holds global environment variables.
///
/// This data structure is part of the API. It's there
/// to make functions or values available to a WLambda program.
///
/// This environment structure is usually wrapped inside an [EvalContext](struct.EvalContext.html)
/// which augments it for calling the compiler and allows evaluation
/// of the code.
///
/// **See also:**
/// - [GlobalEnv::add_func()](#method.add_func) of how to create a function and put it
/// into the global variable.
/// - And [GlobalEnv::set_module()](#method.set_module) of how to supply your own importable
/// modules. See also [SymbolTable](struct.SymbolTable.html) has a good example how that could work.
/// - And [GlobalEnv::set_var()](#method.set_var).
/// - And [GlobalEnv::get_var()](#method.get_var).
#[derive(Clone)]
pub struct GlobalEnv {
    env: std::collections::HashMap<String, VVal>,
    mem_modules:
        std::rc::Rc<std::cell::RefCell<std::collections::HashMap<String, SymbolTable>>>,
    pub resolver: Option<Rc<RefCell<dyn ModuleResolver>>>,
    thread_creator: Option<Arc<Mutex<dyn ThreadCreator>>>,
}

impl std::fmt::Debug for GlobalEnv {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        write!(f, "<<GlobalEnv>>")
    }
}

/// Reference type of `GlobalEnv`.
pub type GlobalEnvRef = Rc<RefCell<GlobalEnv>>;

impl GlobalEnv {
    /// Adds a function to a `GlobalEnv`.
    ///
    /// This is an example of how to add a function:
    ///
    /// ```
    /// use wlambda::compiler::GlobalEnv;
    /// use wlambda::vval::{Env, VVal};
    ///
    /// let g = GlobalEnv::new();
    /// g.borrow_mut().add_func(
    ///     "push",
    ///     |env: &mut Env, argc: usize| {
    ///         if argc < 2 { return Ok(VVal::None); }
    ///         let v = env.arg(0);
    ///         v.push(env.arg(1).clone());
    ///         Ok(v.clone())
    ///     }, Some(2), Some(2));
    /// ```
    pub fn add_func<T>(&mut self, fnname: &str, fun: T, min_args: Option<usize>, max_args: Option<usize>)
        where T: 'static + Fn(&mut Env, usize) -> Result<VVal,StackAction> {
        self.env.insert(
            String::from(fnname),
            VValFun::new_fun(fun, min_args, max_args, false));
    }

    /// Sets a global variable to a value.
    ///
    /// See also [EvalContext::set_global_var()](struct.EvalContext.html#method.set_global_var)
    #[allow(dead_code)]
    pub fn set_var(&mut self, var: &str, val: &VVal) {
        self.env.insert(String::from(var), val.to_ref());
    }

    /// Returns the value of a global variable.
    ///
    /// See also [EvalContext::get_global_var()](struct.EvalContext.html#method.get_global_var)
    #[allow(dead_code)]
    pub fn get_var(&mut self, var: &str) -> Option<VVal> {
        match self.env.get(var) {
            Some(v) => Some(v.deref()),
            None    => None,
        }
    }

    /// Sets a symbol table for a module before a module asks for it.
    /// Modules set via this function have precedence over resolved modules
    /// via set_resolver().
    ///
    /// Here is an example how to setup your own module:
    ///```
    /// use wlambda::{VVal, EvalContext, GlobalEnv, SymbolTable};
    ///
    /// let my_mod = SymbolTable::new();
    ///
    ///```
    #[allow(dead_code)]
    pub fn set_module(&mut self, mod_name: &str, symtbl: SymbolTable) {
        self.mem_modules.borrow_mut().insert(mod_name.to_string(), symtbl);
    }

    /// Imports all symbols from the designated module with the specified
    /// prefix applied. This does not call out to the resolver and
    /// only works on previously `set_module` modules.
    /// Returns true if the module was found.
    pub fn import_module_as(&mut self, mod_name: &str, prefix: &str) -> bool {
        let prefix =
            if !prefix.is_empty() { prefix.to_string() + ":" }
            else { String::from("") };
        if let Some(st) = self.mem_modules.borrow_mut().get(mod_name) {
            for (k, v) in &st.symbols {
                self.env.insert(prefix.clone() + &k, v.clone());
            }
            true
        } else {
            false
        }
    }

    /// Sets the module resolver. There is a LocalFileModuleResolver available
    /// which loads the modules relative to the current working directory.
    ///
    /// Please note that modules made available using `set_module` have priority
    /// over modules that are provided by the resolver.
    ///
    ///```
    /// use std::rc::Rc;
    /// use std::cell::RefCell;
    ///
    /// let global = wlambda::compiler::GlobalEnv::new_default();
    ///
    /// let lfmr = Rc::new(RefCell::new(
    ///     wlambda::compiler::LocalFileModuleResolver::new()));
    ///
    /// global.borrow_mut().set_resolver(lfmr);
    ///```
    pub fn set_resolver(&mut self, res: Rc<RefCell<dyn ModuleResolver>>) {
        self.resolver = Some(res.clone());
    }

    /// Creates a new completely empty GlobalEnv.
    ///
    /// There is no core language, no std lib. You have
    /// to add all that on your own via `set_var` and `set_module`.
    pub fn new() -> GlobalEnvRef {
        Rc::new(RefCell::new(GlobalEnv {
            env: std::collections::HashMap::new(),
            mem_modules:
                std::rc::Rc::new(std::cell::RefCell::new(
                    std::collections::HashMap::new())),
            resolver: None,
            thread_creator: None,
        }))
    }

    /// Returns a default global environment. Where default means what
    /// the author of WLambda decided what is default at the moment.
    /// For more precise global environment, that is not a completely
    /// moving target consider the alternate constructor variants.
    ///
    /// Global environments constructed with this typically contain:
    ///
    /// - `set_module("wlambda", wlambda::prelude::core_symbol_table())`
    /// - `set_module("std",     wlambda::prelude::std_symbol_table())`
    /// - `set_resolver(Rc::new(RefCell::new(wlambda::compiler::LocalFileModuleResolver::new()))`
    /// - `set_thread_creator(Some(Arc::new(Mutex::new(DefaultThreadCreator::new()))))`
    /// - `import_module_as("wlambda", "")`
    /// - `import_module_as("std", "std")`
    ///
    /// On top of that, the `WLambda` module has been imported without a prefix
    /// and the `std` module has been loaded with an `std:` prefix.
    /// This means you can load and eval scripts you see all over this documentation.
    pub fn new_default() -> GlobalEnvRef {
        let g = Self::new_empty_default();
        g.borrow_mut().import_module_as("wlambda", "");
        g.borrow_mut().import_module_as("std",     "std");
        g
    }

    /// This function adds the modules that were loaded into memory
    /// from the given `parent_global_env` to the current environment.
    pub fn import_modules_from(&mut self, parent_global_env: &GlobalEnv) {
        if parent_global_env.resolver.is_some() {
            self.set_resolver(
                parent_global_env.resolver.as_ref().unwrap().clone());
        }
        for (mod_name, symtbl) in parent_global_env.mem_modules.borrow().iter() {
            self.set_module(mod_name, symtbl.clone());
        }
    }

    /// Imports all functions from the given SymbolTable with the
    /// given prefix to the GlobalEnv.
    pub fn import_from_symtbl(&mut self, prefix: &str, symtbl: SymbolTable) {
        for (k, v) in symtbl.symbols {
            self.env.insert(prefix.to_string() + &k, v.clone());
        }
    }

    /// This is like `new_default` but does not import anything, neither the
    /// core language nor the std module.
    pub fn new_empty_default() -> GlobalEnvRef {
        let g = GlobalEnv::new();
        g.borrow_mut().set_module("wlambda", core_symbol_table());
        g.borrow_mut().set_module("std",     std_symbol_table());
        g.borrow_mut().set_thread_creator(
            Some(Arc::new(Mutex::new(DefaultThreadCreator::new()))));
        g.borrow_mut().set_resolver(
            Rc::new(RefCell::new(LocalFileModuleResolver::new())));
        g
    }

    /// Assigns a new thread creator to this GlobalEnv.
    /// It will be used to spawn new threads if `std:thread:spawn` from
    /// WLambda's standard library is called.
    pub fn set_thread_creator(&mut self,
        tc: Option<Arc<Mutex<dyn ThreadCreator>>>)
    {
        self.thread_creator = tc.clone();
    }

    /// Returns the thread creator for this GlobalEnv if one is set.
    pub fn get_thread_creator(&self)
        -> Option<Arc<Mutex<dyn ThreadCreator>>>
    {
        self.thread_creator.clone()
    }
}

#[derive(Debug)]
/// Errors that can occur when evaluating a piece of WLambda code.
/// Usually created by methods of `EvalContext`.
pub enum EvalError {
    /// Errors regarding file I/O when parsing files
    IOError(String, std::io::Error),
    /// Syntax errors
    ParseError(String),
    /// Grammar/Compilation time errors
    CompileError(CompileError),
    /// Special kinds of runtime errors
    ExecError(StackAction),
}

impl Display for EvalError {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        match self {
            EvalError::IOError(file, e) => write!(f, "IO error: file '{}': {} ", file, e),
            EvalError::ParseError(e)    => write!(f, "Parse error: {}", e),
            EvalError::CompileError(e)  => write!(f, "Compile error: {}", e),
            EvalError::ExecError(s)     => write!(f, "Execution error: Jumped out of execution: {:?}", s),
        }
    }
}

/// This context holds all the data to compile and execute a piece of WLambda code.
/// You can either use the default environment, or customize the EvalContext
/// to your application's needs. You can provide custom:
///
/// - Global environemnt
/// - Module resolver
/// - Custom preset modules
/// - Thread creator
///
/// It can be this easy to create a context:
///
///```
/// let mut ctx = wlambda::EvalContext::new_default();
/// let ret = ctx.eval("10 + 20").unwrap().i();
///
/// assert_eq!(ret, 30);
///
/// // Also works beyond differnt eval() calls:
/// ctx.eval("!:global X = 10").unwrap();
///
/// let ret = ctx.eval("X").unwrap().i();
/// assert_eq!(ret, 10);
///
/// // You can access the global environment later too:
/// assert_eq!(ctx.get_global_var("X").unwrap().i(),
///            10);
///
/// // You can even store top level local variables beyond one eval():
/// ctx.eval("!toplevel_var = { _ + 20 }").unwrap();
/// let ret = ctx.eval("toplevel_var 11").unwrap().i();
///
/// assert_eq!(ret, 31);
///```
///
/// You can also explicitly setup a global environment:
///
///```
/// use wlambda::{GlobalEnv, EvalContext, VVal};
///
/// let genv = GlobalEnv::new_default();
///
/// genv.borrow_mut().set_var("xyz", &VVal::Int(31347));
///
/// let mut ctx = EvalContext::new(genv);
/// let ret = ctx.eval("xyz - 10").unwrap().i();
///
/// assert_eq!(ret, 31337);
///```
#[derive(Debug, Clone)]
pub struct EvalContext {
    /// Holds the reference to the supplied or internally created
    /// GlobalEnv.
    pub global:         GlobalEnvRef,
    local_compile:      Rc<RefCell<CompileEnv>>,
    /// Holds the top level environment data accross multiple eval()
    /// invocations.
    pub local:          Rc<RefCell<Env>>,
}

impl EvalContext {
    pub fn new(global: GlobalEnvRef) -> EvalContext {
        (Self::new_with_user_impl(global, Rc::new(RefCell::new(VVal::vec()))))
        .register_self_eval()
    }

    /// Creates a new EvalContext with an empty GlobalEnv.
    /// This means the EvalContext has none of the core or std library
    /// functions in it's global environment and you have to provide
    /// them yourself. Either by loading them from WLambda by `!@import std`
    /// or `!@wlambda`. Or by manually binding in the corresponding
    /// SymbolTable(s).
    ///
    ///```rust
    /// use wlambda::compiler::EvalContext;
    /// use wlambda::vval::{VVal, VValFun, Env};
    ///
    /// let mut ctx = EvalContext::new_empty_global_env();
    ///
    /// {
    ///     let mut genv = ctx.global.borrow_mut();
    ///     genv.set_module("wlambda", wlambda::prelude::core_symbol_table());
    ///     genv.import_module_as("wlambda", "");
    /// }
    ///
    /// assert_eq!(ctx.eval("type $true").unwrap().s_raw(), "bool")
    ///```
    #[allow(dead_code)]
    pub fn new_empty_global_env() -> EvalContext {
        Self::new_with_user_impl(
            GlobalEnv::new(),
            Rc::new(RefCell::new(VVal::vec())))
    }

    /// A shortcut: This creates a new EvalContext with a GlobalEnv::new_default()
    /// global environment.
    ///
    /// This is a shorthand for:
    ///```
    /// wlambda::compiler::EvalContext::new(
    ///     wlambda::compiler::GlobalEnv::new_default());
    ///```
    #[allow(dead_code)]
    pub fn new_default() -> EvalContext {
        Self::new(GlobalEnv::new_default())
    }

    fn register_self_eval(self) -> Self {
        let ctx_clone =
            Self::new_with_user_impl(
                self.global.clone(),
                self.local.borrow().get_user());

        self.global.borrow_mut().add_func("std:eval", move |env: &mut Env, _argc: usize| {
            let code    = env.arg(0).s_raw();
            let ctx     = ctx_clone.clone();
            let mut ctx = ctx.register_self_eval();
            match ctx.eval(&code) {
                Ok(v)  => Ok(v),
                Err(e) => Ok(env.new_err(format!("{}", e))),
            }
        }, Some(1), Some(2));

        self
    }

    pub fn get_exports(&self) -> SymbolTable {
        SymbolTable { symbols: self.local.borrow_mut().exports.clone() }
    }

    #[allow(dead_code)]
    fn new_with_user_impl(
        global: GlobalEnvRef, user: Rc<RefCell<dyn std::any::Any>>) -> EvalContext {

        EvalContext {
            global: global.clone(),
            local_compile: Rc::new(RefCell::new(CompileEnv {
                parent:    None,
                global: global.clone(),
                block_env: BlockEnv::new(),
                upvals:    Vec::new(),
                locals_space: 0,
                recent_var: String::new(),
                recent_sym: String::new(),
                implicit_arity: (ArityParam::Undefined, ArityParam::Undefined),
                explicit_arity: (ArityParam::Undefined, ArityParam::Undefined),
                quote_func: false,
            })),
            local: Rc::new(RefCell::new(Env::new_with_user(global, user))),
        }
    }

    #[allow(dead_code)]
    pub fn new_with_user(global: GlobalEnvRef, user: Rc<RefCell<dyn std::any::Any>>) -> EvalContext {
        (Self::new_with_user_impl(global, user)).register_self_eval()
    }

    /// Evaluates an AST of WLambda code and executes it with the given `EvalContext`.
    ///
    /// ```
    /// use wlambda::parser;
    /// let mut ctx = wlambda::EvalContext::new_default();
    ///
    /// let s = "$[1,2,3]";
    /// let ast = parser::parse(s, "somefilename").unwrap();
    /// let r = &mut ctx.eval_ast(&ast).unwrap();
    ///
    /// println!("Res: {}", r.s());
    /// ```
    pub fn eval_ast(&mut self, ast: &VVal) -> Result<VVal, EvalError>  {
        let prog = crate::vm::compile_vm_fun(ast, &mut self.local_compile);
        let locals_size = self.local_compile.borrow().get_local_space();

        let env = self.local.borrow_mut();
        let mut res = Ok(VVal::None);

        std::cell::RefMut::map(env, |l_env| {
            res = match prog {
                Ok(prog_closures) => {
                    l_env.sp = 0;
                    l_env.set_bp(locals_size);
                    match l_env.with_restore_sp(|e: &mut Env| { prog_closures(e) }) {
                        Ok(v)   => Ok(v),
                        Err(je) => Err(EvalError::ExecError(je)),
                    }
                },
                Err(e) => Err(EvalError::CompileError(e)),
            };
            l_env
        });

        res
    }

    /// Evaluates a WLambda code in a file with the given `EvalContext`.
    ///
    /// ```
    /// let mut ctx = wlambda::EvalContext::new_default();
    ///
    /// let r = &mut ctx.eval_file("examples/read_test.wl").unwrap();
    /// assert_eq!(r.i(), 403, "matches contents!");
    /// ```
    #[allow(dead_code)]
    pub fn eval_file(&mut self, filename: &str) -> Result<VVal, EvalError> {
        let contents = std::fs::read_to_string(filename);
        if let Err(err) = contents {
            Err(EvalError::IOError(filename.to_string(), err))
        } else {
            let contents = contents.unwrap();
            match parser::parse(&contents, filename) {
                Ok(ast) => self.eval_ast(&ast),
                Err(e)  => Err(EvalError::ParseError(e)),
            }
        }
    }

    /// Evaluates a piece of WLambda code with the given `EvalContext`.
    ///
    /// ```
    /// let mut ctx = wlambda::EvalContext::new_default();
    ///
    /// let r = &mut ctx.eval("$[1,2,3]").unwrap();
    /// println!("Res: {}", r.s());
    /// ```
    #[allow(dead_code)]
    pub fn eval(&mut self, s: &str) -> Result<VVal, EvalError>  {
        match parser::parse(s, "<wlambda::eval>") {
            Ok(ast) => self.eval_ast(&ast),
            Err(e)  => Err(EvalError::ParseError(e)),
        }
    }

    /// Evaluates a WLambda code with the corresponding filename
    /// in the given `EvalContext`.
    ///
    /// ```
    /// let mut ctx = wlambda::EvalContext::new_default();
    ///
    /// let r = &mut ctx.eval_string("403", "examples/read_test.wl").unwrap();
    /// assert_eq!(r.i(), 403, "matches contents!");
    /// ```
    #[allow(dead_code)]
    pub fn eval_string(&mut self, code: &str, filename: &str)
        -> Result<VVal, EvalError>
    {
        match parser::parse(code, filename) {
            Ok(ast) => self.eval_ast(&ast),
            Err(e)  => Err(EvalError::ParseError(e)),
        }
    }

    /// Calls a wlambda function with the given `EvalContext`.
    ///
    /// ```
    /// use wlambda::{VVal, EvalContext};
    /// let mut ctx = EvalContext::new_default();
    ///
    /// let returned_func = &mut ctx.eval("{ _ + _1 }").unwrap();
    /// assert_eq!(
    ///     ctx.call(returned_func,
    ///              &vec![VVal::Int(10), VVal::Int(11)]).unwrap().i(),
    ///     21);
    /// ```
    #[allow(dead_code)]
    pub fn call(&mut self, f: &VVal, args: &[VVal]) -> Result<VVal, StackAction>  {
        let mut env = self.local.borrow_mut();
        f.call(&mut env, args)
    }

    /// Sets a global variable for the scripts to access.
    ///
    /// ```
    /// use wlambda::{VVal, EvalContext};
    /// let mut ctx = EvalContext::new_default();
    ///
    /// ctx.set_global_var("XXX", &VVal::Int(200));
    ///
    /// assert_eq!(ctx.eval("XXX * 2").unwrap().i(), 400);
    /// ```
    #[allow(dead_code)]
    pub fn set_global_var(&mut self, var: &str, val: &VVal) {
        self.global.borrow_mut().set_var(var, val);
    }

    /// Gets the value of a global variable from the script:
    ///
    /// ```
    /// use wlambda::{VVal, EvalContext};
    /// let mut ctx = EvalContext::new_default();
    ///
    /// ctx.eval("!:global XXX = 22 * 2;");
    ///
    /// assert_eq!(ctx.get_global_var("XXX").unwrap().i(), 44);
    /// ```
    #[allow(dead_code)]
    pub fn get_global_var(&mut self, var: &str) -> Option<VVal> {
        self.global.borrow_mut().get_var(var)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum ArityParam {
    Undefined,
    Limit(usize),
    Infinite,
}

#[derive(Debug, Clone)]
struct BlockEnv {
    local_map_stack: std::vec::Vec<(usize, Box<std::collections::HashMap<String, VarPos>>)>,
    reuse_stk_slot: Rc<RefCell<std::vec::Vec<usize>>>,
    locals:          std::vec::Vec<(String, CompileLocal)>,
}

#[derive(Debug,Clone,Copy,PartialEq)]
#[repr(u8)]
pub enum ResValue {
    None,
    OptNone,
    Ret,
    AccumVal,
    AccumFun,
    SelfObj,
    SelfData,
}

#[derive(Debug,Clone,Copy,PartialEq)]
#[repr(u8)]
pub enum ResPos {
    Local(u16),
    LocalRef(u16),
    Arg(u16),
    Up(u16),
    UpRef(u16),
    Global(u16),
    GlobalRef(u16),
    Data(u16),
    Stack(u16),
    Value(ResValue),
}

impl BlockEnv {
    fn new() -> Self {
        Self {
            local_map_stack: vec![(0, Box::new(std::collections::HashMap::new()))],
            locals:          vec![],
            reuse_stk_slot: Rc::new(RefCell::new(vec![])),
        }
    }

/*

    !x = $p(:Move, :Down);

    ?* x
        $p(:Move, pos) => {
            std:displayln "Moving to " pos;
        }
        $p(:Jump, strength) => {
            std:displayln "I Jumped: " strength;
        };

*/
    fn env_size(&self) -> usize {
        self.locals.len()
    }

    fn push_env(&mut self) {
        self.local_map_stack.push((0, Box::new(std::collections::HashMap::new())));
    }

    fn pop_env(&mut self) -> (usize, usize) {
        let block_env_vars = self.local_map_stack.pop().unwrap();

        let local_count = block_env_vars.0;
        for _ in 0..local_count {
            self.locals.pop();
        }

        (self.locals.len(), self.locals.len() + local_count)
    }

    fn set_upvalue(&mut self, var: &str, idx: usize) -> VarPos {
        let last_idx = self.local_map_stack.len() - 1;
        self.local_map_stack[last_idx].1
            .insert(String::from(var),
                    VarPos::UpValue(idx));
        VarPos::UpValue(idx)
    }

    fn next_local(&mut self) -> usize {
        let next_index = self.locals.len();
        self.locals.push((String::from(""), CompileLocal { }));
        next_index
    }

    fn def_local(&mut self, var: &str, idx: usize) {
        self.locals[idx].0 = String::from(var);
        let last_idx = self.local_map_stack.len() - 1;
        self.local_map_stack[last_idx].1
            .insert(String::from(var),
                    VarPos::Local(idx));
        self.local_map_stack[last_idx].0 += 1;
    }

    fn get(&self, var: &str) -> VarPos {
        for (_locals, map) in self.local_map_stack.iter().rev() {
            if let Some(pos) = map.get(var) {
                return pos.clone();
            }
        }

        VarPos::NoPos
    }
}

/// Compile time environment for allocating and
/// storing variables inside a function scope.
///
/// Also handles upvalues. Upvalues in WLambda are copied to every
/// scope that they are passed through until they are needed.
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CompileEnv {
    /// Reference to the global environment
    pub global:    GlobalEnvRef,
    /// Reference to the environment of the _parent_ function.
    parent:    Option<Rc<RefCell<CompileEnv>>>,
    /// Holds all function local variables and manages nesting of blocks.
    block_env: BlockEnv,
    /// Holds the maximum number of locals ever used:
    locals_space: usize,
    /// Stores position of the upvalues for copying the upvalues at runtime.
    upvals:    std::vec::Vec<VarPos>,
    /// Stores the implicitly calculated arity of this function.
    pub implicit_arity: (ArityParam, ArityParam),
    /// Stores the explicitly defined arity of this function.
    pub explicit_arity: (ArityParam, ArityParam),
    /// Recently accessed variable name:
    pub recent_var: String,
    /// Recently compiled symbol:
    pub recent_sym: String,
    /// If set, the next compile() is compiling a function as block.
    pub quote_func: bool,
}

/// Reference type to a `CompileEnv`.
type CompileEnvRef = Rc<RefCell<CompileEnv>>;

impl CompileEnv {
    pub fn new(g: GlobalEnvRef) -> Rc<RefCell<Self>> {
        Rc::new(RefCell::new(CompileEnv {
            parent:    None,
            global:    g,
            block_env: BlockEnv::new(),
            upvals:    Vec::new(),
            locals_space: 0,
            quote_func: false,
            recent_var: String::new(),
            recent_sym: String::new(),
            implicit_arity: (ArityParam::Undefined, ArityParam::Undefined),
            explicit_arity: (ArityParam::Undefined, ArityParam::Undefined),
        }))
    }

    pub fn create_env(parent: Option<CompileEnvRef>) -> Rc<RefCell<CompileEnv>> {
        let global = if let Some(p) = &parent {
            p.borrow_mut().global.clone()
        } else {
            GlobalEnv::new()
        };
        Rc::new(RefCell::new(CompileEnv {
            parent,
            global,
            block_env: BlockEnv::new(),
            upvals:    Vec::new(),
            locals_space: 0,
            recent_var: String::new(),
            recent_sym: String::new(),
            implicit_arity: (ArityParam::Undefined, ArityParam::Undefined),
            explicit_arity: (ArityParam::Undefined, ArityParam::Undefined),
            quote_func: false,
        }))
    }

    fn def_up(&mut self, s: &str, parent_local_var: VarPos) -> VarPos {
        let next_index = self.upvals.len();
        self.upvals.push(parent_local_var);
        self.block_env.set_upvalue(s, next_index)
    }

    pub fn def_const(&mut self, s: &str, val: VVal) {
        self.global.borrow_mut().env.insert(String::from(s), val);
    }

    pub fn def_local(&mut self, s: &str, idx: usize) {
        self.block_env.def_local(s, idx);
    }

    pub fn next_local(&mut self) -> usize {
        let idx = self.block_env.next_local();
        if (idx + 1) > self.locals_space {
            self.locals_space = idx + 1;
        }
        idx
    }

    pub fn get_local_space(&self) -> usize { self.locals_space }

    pub fn def(&mut self, s: &str, is_global: bool) -> VarPos {
        if is_global {
            let v = VVal::None;
            let r = v.to_ref();
            self.global.borrow_mut().env.insert(String::from(s), r.clone());
            VarPos::Global(r)
        } else {
            let idx = self.block_env.next_local();
            if (idx + 1) > self.locals_space {
                self.locals_space = idx + 1;
            }
            self.block_env.def_local(s, idx);
            VarPos::Local(idx)
        }
    }

    pub fn get_upval_pos(&self) -> std::vec::Vec<VarPos> {
        let mut poses = vec![];
        for p in self.upvals.iter() {
            match p {
                VarPos::UpValue(_) => poses.push(p.clone()),
                VarPos::Local(_)   => poses.push(p.clone()),
                VarPos::Global(_) => {
                    panic!("Globals can't be captured as upvalues!");
                },
                VarPos::Const(_) => {
                    panic!("Consts can't be captured as upvalues!");
                },
                VarPos::NoPos => poses.push(p.clone()),
            }
        }
        poses
    }

    pub fn local_env_size(&self) -> usize {
        self.block_env.env_size()
    }

    pub fn push_block_env(&mut self) {
        self.block_env.push_env();
    }

    pub fn pop_block_env(&mut self) -> (usize, usize) {
        self.block_env.pop_env()
    }

    pub fn get(&mut self, s: &str) -> VarPos {
        let pos = self.block_env.get(s);
        match pos {
            VarPos::NoPos => {
                let opt_p = self.parent.as_mut();
                if opt_p.is_none() {
                    if let Some(v) = self.global.borrow().env.get(s){
                        if v.is_ref() {
                            return VarPos::Global(v.clone());
                        } else {
                            return VarPos::Const(v.clone());
                        }
                    } else {
                        return VarPos::NoPos;
                    }
                }
                let parent = opt_p.unwrap().clone();
                let mut par_mut = parent.borrow_mut();

                let par_var_pos = par_mut.block_env.get(s);
                let par_var_pos = match par_var_pos {
                    VarPos::NoPos => par_mut.get(s),
                    _             => par_var_pos,
                };
                match par_var_pos {
                    VarPos::Local(_)   => self.def_up(s, par_var_pos),
                    VarPos::UpValue(_) => self.def_up(s, par_var_pos),
                    VarPos::Global(g)  => VarPos::Global(g),
                    VarPos::Const(c)   => VarPos::Const(c),
                    VarPos::NoPos      => VarPos::NoPos
                }
            }
            _ => pos.clone(),
        }
    }
}

pub fn set_impl_arity(i: usize, ce: &mut Rc<RefCell<CompileEnv>>) {
    let min = ce.borrow().implicit_arity.0.clone();
    match min {
        ArityParam::Undefined => { ce.borrow_mut().implicit_arity.0 = ArityParam::Limit(i); },
        ArityParam::Limit(j) => { if j < i { ce.borrow_mut().implicit_arity.0 = ArityParam::Limit(i); }; },
        _ => (),
    }

    let max = ce.borrow_mut().implicit_arity.1.clone();
    match max {
        ArityParam::Undefined => {
            ce.borrow_mut().implicit_arity.1 = ArityParam::Limit(i);
        },
        ArityParam::Limit(j) => {
            if j < i { ce.borrow_mut().implicit_arity.1 = ArityParam::Limit(i); }
        },
        _ => (),
    }
}

pub fn check_for_at_arity(prev_arity: (ArityParam, ArityParam), ast: &VVal, ce: &mut Rc<RefCell<CompileEnv>>, vars: &VVal) {
    // If we have an destructuring assignment directly from "@", then we conclude
    // the implicit max arity to be minimum of number of vars:
    if ast.at(2).unwrap_or(VVal::None).at(0).unwrap_or(VVal::None).get_syn() == Syntax::Var {
        if let VVal::Lst(l) = vars {
            let llen = l.borrow().len();

            let var = ast.at(2).unwrap().at(1).unwrap();
            if var.with_s_ref(|var: &str| var == "@") {
                ce.borrow_mut().implicit_arity = prev_arity;
                set_impl_arity(llen, ce);
            }
        }
    }
}

pub fn fetch_object_key_access(ast: &VVal) -> Option<(Syntax, VVal, VVal)> {
    let syn = ast.v_(0).get_syn();
    match syn {
        Syntax::GetKey => {
            Some((Syntax::GetKey, ast.v_(1), ast.v_(2)))
        },
        Syntax::GetKey2 => {
            let mut get_obj = ast.shallow_clone();
            get_obj.set_syn_at(0, Syntax::GetKey);
            let key = get_obj.pop();
            Some((Syntax::GetKey, get_obj, key))
        },
        Syntax::GetKey3 => {
            let mut get_obj = ast.shallow_clone();
            get_obj.set_syn_at(0, Syntax::GetKey2);
            let key = get_obj.pop();
            Some((Syntax::GetKey, get_obj, key))
        },
        Syntax::GetSym => {
            Some((Syntax::GetSym, ast.v_(1), ast.v_(2)))
        },
        Syntax::GetSym2 => {
            let mut get_obj = ast.shallow_clone();
            get_obj.set_syn_at(0, Syntax::GetSym);
            let key = get_obj.pop();
            Some((Syntax::GetSym, get_obj, key))
        },
        Syntax::GetSym3 => {
            let mut get_obj = ast.shallow_clone();
            get_obj.set_syn_at(0, Syntax::GetSym2);
            let key = get_obj.pop();
            Some((Syntax::GetSym, get_obj, key))
        },
        _ => None,
    }
}

pub fn copy_upvs(upvs: &[VarPos], e: &mut Env, upvalues: &mut std::vec::Vec<VVal>) {
    for u in upvs.iter() {
        match u {
            VarPos::UpValue(i) => upvalues.push(e.get_up_raw(*i)),
            VarPos::Local(i)   => upvalues.push(e.get_local_up_promotion(*i)),
            VarPos::NoPos      => upvalues.push(VVal::None.to_ref()),
            VarPos::Global(_)  => (),
            VarPos::Const(_)   => (),
        }
    }
}



/// Evaluates a piece of WLambda code in a default global environment.
///
/// ```
/// println!("> {}", wlambda::eval("${a = 10, b = 20}").unwrap().s());
/// ```
#[allow(dead_code)]
pub fn eval(s: &str) -> Result<VVal, EvalError>  {
    let mut ctx = EvalContext::new_default();
    ctx.eval(s)
}

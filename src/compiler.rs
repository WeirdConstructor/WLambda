// Copyright (c) 2020 Weird Constructor <weirdconstructor@gmail.com>
// This is a part of WLambda. See README.md and COPYING for details.

/*!

  Implements all the semantics of WLambda. It takes an AST
  that was generated by the parser and compiles it to a
  tree of closures.

  The compiler and the runtime require multiple
  other data structures, such as `GlobalEnv` with a
  `SymbolTable` for global functions,
  a `ModuleResolver` and a `ThreadCreator`.

  An to execute the closures that the compiler generated
  you need an `Env` instance (which itself requires a reference
  to the `GlobalEnv`.

  To orchestrate all this the `EvalContext` exists.
  You can customize:

  - The `GlobalEnv` with custom
  globals and even with your own core and standard library functions
  - You can provide a custom `ModuleResolver`, which loads the
  modules from other sources (eg. memory or network).
  - You can make your own `ThreadCreator`, to customize thread
  creation.

  However, to get some WLambda code running quickly there is
  `EvalContext::new_default()` which creates a ready made context for
  evaluating WLambda code:


```
use wlambda::*;

let mut ctx = EvalContext::new_default();
let res = ctx.eval("$[10, 20 + 30]").unwrap();

assert_eq!(res.s(), "$[10,50]");
```

*/

use crate::parser::{self};
use crate::prelude::*;
use crate::vval::VVal;
use crate::vval::SynPos;
use crate::vval::Syntax;
use crate::vval::Env;
use crate::vval::VValFun;
use crate::vval::EvalNode;
use crate::vval::StackAction;
use crate::vval::CompileError;
use crate::vval::VarPos;
use crate::threads::*;
use std::rc::Rc;
use std::sync::Arc;
use std::sync::Mutex;
use std::cell::RefCell;
use std::fmt::{Display, Formatter};

use fnv::FnvHashMap;

#[allow(dead_code)]
#[derive(Debug, Clone, PartialEq)]
struct CompileLocal {
}

#[derive(Debug)]
/// Error for the `ModuleResolver` trait, to implement
/// custom module loading behaviour.
#[allow(dead_code)]
pub enum ModuleLoadError<'a> {
    NoSuchModule(String),
    ModuleEvalError(EvalError),
    Other(&'a str),
}

/// This trait is responsible for loading modules
/// and returning a collection of name->value mappings for a module
/// name.
///
/// See also GlobalEnv::set_resolver() about how to configure the
/// global environment to use you trait implementation.
///
/// There is a default implementation named LocalFileModuleResolver,
/// which loads the modules from files.
pub trait ModuleResolver {
    /// Resolves the path to a HashMap of names -> VVal.
    /// Where you obtain this mapping from is completely up to you.
    /// You can statically define these, load them from a JSON file,
    /// load them by executing another WLambda script or whatever you fancy.
    ///
    /// See LocalFileModuleResolver as example on how to implement this.
    fn resolve(&self, global: GlobalEnvRef, path: &[String], import_file_path: Option<&str>) -> Result<SymbolTable, ModuleLoadError>;
}

/// This structure implements the ModuleResolver trait and is
/// responsible for loading modules on `!@import` for WLambda.
#[derive(Debug, Clone, Default)]
pub struct LocalFileModuleResolver { }

#[allow(dead_code)]
impl LocalFileModuleResolver {
    pub fn new() -> LocalFileModuleResolver {
        LocalFileModuleResolver { }
    }
}

/// Stores symbols and values for a WLambda module that can be added to a `GlobalEnv` with `set_module`.
///
///```
/// use wlambda::{SymbolTable, GlobalEnv, EvalContext, Env};
///
/// let mut st = SymbolTable::new();
///
/// let outbuf = std::rc::Rc::new(std::cell::RefCell::new(String::from("")));
///
/// let captured_outbuf = outbuf.clone();
///
/// st.fun("print", move |e: &mut Env, _argc: usize| {
///     std::mem::replace(&mut *captured_outbuf.borrow_mut(), e.arg(0).s());
///     println!("MY PRINT: {}", e.arg(0).s());
///     Ok(e.arg(0).clone())
/// }, Some(1), Some(1), false);
///
/// let global_env = GlobalEnv::new_default();
/// global_env.borrow_mut().set_module("my", st);
///
/// let mut ctx = EvalContext::new(global_env);
/// ctx.eval("!@import my my; my:print 1337");
///
/// assert_eq!(outbuf.borrow().clone(), "1337");
///```
#[derive(Default, Debug, Clone)]
pub struct SymbolTable {
    symbols: FnvHashMap<String, VVal>,
}

impl SymbolTable {
    pub fn new() -> Self {
        SymbolTable {
            symbols: FnvHashMap::with_capacity_and_hasher(10, Default::default()),
        }
    }

    /// This function returns all symbols defined in this SymbolTable.
    /// It's mainly used for tests.
    #[allow(dead_code)]
    pub fn list(&self) -> std::vec::Vec<String> {
        let mut v = vec![];
        for (s, _) in self.symbols.iter() {
            v.push(s.to_string());
        }
        v
    }

    /// Sets the entry `name` to the `value`. So that the
    /// value can be imported.
    #[allow(dead_code)]
    pub fn set(&mut self, name: &str, value: VVal) {
        self.symbols.insert(String::from(name), value);
    }
    
    /// Retrieves a value from the SymbolTable, if present.
    /// ```
    /// use wlambda::{VVal, EvalContext};
    /// let mut ctx = EvalContext::new_default();
    /// ctx.eval("!@export to_rust = 42.0;");
    ///
    /// assert_eq!(ctx.get_exports().get("to_rust").cloned(), Some(VVal::Flt(42.0)));
    /// ```
    #[allow(dead_code)]
    pub fn get(&mut self, name: &str) -> Option<&VVal> {
        self.symbols.get(name)
    }

    /// Helper function for building symbol tables with functions in them.
    ///
    /// See also `VValFun::new_fun` for more details.
    ///
    ///```
    /// use wlambda::VVal;
    /// let mut st = wlambda::compiler::SymbolTable::new();
    /// st.fun("nothing",
    ///        |e: &mut wlambda::vval::Env, _argc: usize| Ok(VVal::Nul),
    ///        None, None, false);
    ///```
    pub fn fun<T>(
        &mut self, fnname: &str, fun: T,
        min_args: Option<usize>,
        max_args: Option<usize>,
        err_arg_ok: bool)
        where T: 'static + Fn(&mut Env, usize) -> Result<VVal,StackAction> {

        self.symbols.insert(
            String::from(fnname), VValFun::new_fun(fun, min_args, max_args, err_arg_ok));
    }
}

impl ModuleResolver for LocalFileModuleResolver {
    fn resolve(&self, global: GlobalEnvRef, path: &[String], import_file_path: Option<&str>)
        -> Result<SymbolTable, ModuleLoadError>
    {
        let genv = GlobalEnv::new_empty_default();
        genv.borrow_mut().set_thread_creator(
            global.borrow().get_thread_creator());
        genv.borrow_mut().import_modules_from(&*global.borrow());

        let mut ctx = EvalContext::new(genv);
        let pth = format!("{}.wl", path.join("/"));
        let mut check_paths = vec![pth];

        if let Some(ifp) = import_file_path {
            let impfp = std::path::Path::new(ifp);

            let import_dir_path =
                if impfp.is_file() {
                    impfp.parent()
                } else {
                    Some(impfp)
                };

            if let Some(idp) = import_dir_path {
                let mut pb = idp.to_path_buf();
                for p in path { pb.push(p); }

                if let Some(p) = pb.as_path().to_str() {
                    check_paths.push(format!("{}.wl", p));
                }
            }
        }

        for pth in check_paths.iter() {
            if std::path::Path::new(pth).exists() {
                return match ctx.eval_file(pth) {
                    Err(e) => Err(ModuleLoadError::ModuleEvalError(e)),
                    Ok(_v) => Ok(ctx.get_exports()),
                }
            }
        }

        Err(ModuleLoadError::NoSuchModule(check_paths.join(";")))
    }
}

/// Holds global environment variables.
///
/// This data structure is part of the API. It's there
/// to make functions or values available to a WLambda program.
///
/// This environment structure is usually wrapped inside an [EvalContext](struct.EvalContext.html)
/// which augments it for calling the compiler and allows evaluation
/// of the code.
///
/// **See also:**
/// - [GlobalEnv::add_func()](#method.add_func) of how to create a function and put it
/// into the global variable.
/// - And [GlobalEnv::set_module()](#method.set_module) of how to supply your own importable
/// modules. See also [SymbolTable](struct.SymbolTable.html) has a good example how that could work.
/// - And [GlobalEnv::set_var()](#method.set_var).
/// - And [GlobalEnv::get_var()](#method.get_var).
#[derive(Clone)]
pub struct GlobalEnv {
    env: std::collections::HashMap<String, VVal>,
    mem_modules:
        std::rc::Rc<std::cell::RefCell<std::collections::HashMap<String, SymbolTable>>>,
    resolver: Option<Rc<RefCell<dyn ModuleResolver>>>,
    thread_creator: Option<Arc<Mutex<dyn ThreadCreator>>>,
}

impl std::fmt::Debug for GlobalEnv {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        write!(f, "<<GlobalEnv>>")
    }
}

/// Reference type of `GlobalEnv`.
pub type GlobalEnvRef = Rc<RefCell<GlobalEnv>>;

impl GlobalEnv {
    /// Adds a function to a `GlobalEnv`.
    ///
    /// This is an example of how to add a function:
    ///
    /// ```
    /// use wlambda::compiler::GlobalEnv;
    /// use wlambda::vval::{Env, VVal};
    ///
    /// let g = GlobalEnv::new();
    /// g.borrow_mut().add_func(
    ///     "push",
    ///     |env: &mut Env, argc: usize| {
    ///         if argc < 2 { return Ok(VVal::Nul); }
    ///         let v = env.arg(0);
    ///         v.push(env.arg(1).clone());
    ///         Ok(v.clone())
    ///     }, Some(2), Some(2));
    /// ```
    pub fn add_func<T>(&mut self, fnname: &str, fun: T, min_args: Option<usize>, max_args: Option<usize>)
        where T: 'static + Fn(&mut Env, usize) -> Result<VVal,StackAction> {
        self.env.insert(
            String::from(fnname),
            VValFun::new_fun(fun, min_args, max_args, false));
    }

    /// Sets a global variable to a value.
    ///
    /// See also [EvalContext::set_global_var()](struct.EvalContext.html#method.set_global_var)
    #[allow(dead_code)]
    pub fn set_var(&mut self, var: &str, val: &VVal) {
        self.env.insert(String::from(var), val.to_ref());
    }

    /// Returns the value of a global variable.
    ///
    /// See also [EvalContext::get_global_var()](struct.EvalContext.html#method.get_global_var)
    #[allow(dead_code)]
    pub fn get_var(&mut self, var: &str) -> Option<VVal> {
        match self.env.get(var) {
            Some(v) => Some(v.deref()),
            None    => None,
        }
    }

    /// Sets a symbol table for a module before a module asks for it.
    /// Modules set via this function have precedence over resolved modules
    /// via set_resolver().
    ///
    /// Here is an example how to setup your own module:
    ///```
    /// use wlambda::{VVal, EvalContext, GlobalEnv, SymbolTable};
    ///
    /// let my_mod = SymbolTable::new();
    ///
    ///```
    #[allow(dead_code)]
    pub fn set_module(&mut self, mod_name: &str, symtbl: SymbolTable) {
        self.mem_modules.borrow_mut().insert(mod_name.to_string(), symtbl);
    }

    /// Imports all symbols from the designated module with the specified
    /// prefix applied. This does not call out to the resolver and
    /// only works on previously `set_module` modules.
    pub fn import_module_as(&mut self, mod_name: &str, prefix: &str) {
        let prefix =
            if !prefix.is_empty() { prefix.to_string() + ":" }
            else { String::from("") };
        if let Some(st) = self.mem_modules.borrow_mut().get(mod_name) {
            for (k, v) in &st.symbols {
                self.env.insert(prefix.clone() + &k, v.clone());
            }
        }
    }

    /// Sets the module resolver. There is a LocalFileModuleResolver available
    /// which loads the modules relative to the current working directory.
    ///
    /// Please note that modules made available using `set_module` have priority
    /// over modules that are provided by the resolver.
    ///
    ///```
    /// use std::rc::Rc;
    /// use std::cell::RefCell;
    ///
    /// let global = wlambda::compiler::GlobalEnv::new_default();
    ///
    /// let lfmr = Rc::new(RefCell::new(
    ///     wlambda::compiler::LocalFileModuleResolver::new()));
    ///
    /// global.borrow_mut().set_resolver(lfmr);
    ///```
    pub fn set_resolver(&mut self, res: Rc<RefCell<dyn ModuleResolver>>) {
        self.resolver = Some(res.clone());
    }

    /// Creates a new completely empty GlobalEnv.
    ///
    /// There is no core language, no std lib. You have
    /// to add all that on your own via `set_var` and `set_module`.
    pub fn new() -> GlobalEnvRef {
        Rc::new(RefCell::new(GlobalEnv {
            env: std::collections::HashMap::new(),
            mem_modules:
                std::rc::Rc::new(std::cell::RefCell::new(
                    std::collections::HashMap::new())),
            resolver: None,
            thread_creator: None,
        }))
    }

    /// Returns a default global environment. Where default means what
    /// the author of WLambda decided what is default at the moment.
    /// For more precise global environment, that is not a completely
    /// moving target consider the alternate constructor variants.
    ///
    /// Global environments constructed with this typically contain:
    ///
    /// - `set_module("wlambda", wlambda::prelude::core_symbol_table())`
    /// - `set_module("std",     wlambda::prelude::std_symbol_table())`
    /// - `set_resolver(Rc::new(RefCell::new(wlambda::compiler::LocalFileModuleResolver::new()))`
    /// - `set_thread_creator(Some(Arc::new(Mutex::new(DefaultThreadCreator::new()))))`
    /// - `import_module_as("wlambda", "")`
    /// - `import_module_as("std", "std")`
    ///
    /// On top of that, the `WLambda` module has been imported without a prefix
    /// and the `std` module has been loaded with an `std:` prefix.
    /// This means you can load and eval scripts you see all over this documentation.
    pub fn new_default() -> GlobalEnvRef {
        let g = Self::new_empty_default();
        g.borrow_mut().import_module_as("wlambda", "");
        g.borrow_mut().import_module_as("std",     "std");
        g
    }

    /// This function adds the modules that were loaded into memory
    /// from the given `parent_global_env` to the current environment.
    pub fn import_modules_from(&mut self, parent_global_env: &GlobalEnv) {
        if parent_global_env.resolver.is_some() {
            self.set_resolver(
                parent_global_env.resolver.as_ref().unwrap().clone());
        }
        for (mod_name, symtbl) in parent_global_env.mem_modules.borrow().iter() {
            self.set_module(mod_name, symtbl.clone());
        }
    }

    /// This is like `new_default` but does not import anything, neither the
    /// core language nor the std module.
    pub fn new_empty_default() -> GlobalEnvRef {
        let g = GlobalEnv::new();
        g.borrow_mut().set_module("wlambda", core_symbol_table());
        g.borrow_mut().set_module("std",     std_symbol_table());
        g.borrow_mut().set_thread_creator(
            Some(Arc::new(Mutex::new(DefaultThreadCreator::new()))));
        g.borrow_mut().set_resolver(
            Rc::new(RefCell::new(LocalFileModuleResolver::new())));
        g
    }

    /// Assigns a new thread creator to this GlobalEnv.
    /// It will be used to spawn new threads if `std:thread:spawn` from
    /// WLambda's standard library is called.
    pub fn set_thread_creator(&mut self,
        tc: Option<Arc<Mutex<dyn ThreadCreator>>>)
    {
        self.thread_creator = tc.clone();
    }

    /// Returns the thread creator for this GlobalEnv if one is set.
    pub fn get_thread_creator(&self)
        -> Option<Arc<Mutex<dyn ThreadCreator>>>
    {
        self.thread_creator.clone()
    }
}

#[derive(Debug)]
/// Errors that can occur when evaluating a piece of WLambda code.
/// Usually created by methods of `EvalContext`.
pub enum EvalError {
    /// Errors regarding file I/O when parsing files
    IOError(String, std::io::Error),
    /// Syntax errors
    ParseError(String),
    /// Grammar/Compilation time errors
    CompileError(CompileError),
    /// Special kinds of runtime errors
    ExecError(StackAction),
}

impl Display for EvalError {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        match self {
            EvalError::IOError(file, e) => write!(f, "IO error: file '{}': {} ", file, e),
            EvalError::ParseError(e)    => write!(f, "Parse error: {}", e),
            EvalError::CompileError(e)  => write!(f, "Compile error: {}", e),
            EvalError::ExecError(s)     => write!(f, "Execution error: Jumped out of execution: {:?}", s),
        }
    }
}

/// This context holds all the data to compile and execute a piece of WLambda code.
/// You can either use the default environment, or customize the EvalContext
/// to your application's needs. You can provide custom:
///
/// - Global environemnt
/// - Module resolver
/// - Custom preset modules
/// - Thread creator
///
/// It can be this easy to create a context:
///
///```
/// let mut ctx = wlambda::EvalContext::new_default();
/// let ret = ctx.eval("10 + 20").unwrap().i();
///
/// assert_eq!(ret, 30);
///
/// // Also works beyond differnt eval() calls:
/// ctx.eval("!:global X = 10").unwrap();
///
/// let ret = ctx.eval("X").unwrap().i();
/// assert_eq!(ret, 10);
///
/// // You can access the global environment later too:
/// assert_eq!(ctx.get_global_var("X").unwrap().i(),
///            10);
///
/// // You can even store top level local variables beyond one eval():
/// ctx.eval("!toplevel_var = { _ + 20 }").unwrap();
/// let ret = ctx.eval("toplevel_var 11").unwrap().i();
///
/// assert_eq!(ret, 31);
///```
///
/// You can also explicitly setup a global environment:
///
///```
/// use wlambda::{GlobalEnv, EvalContext, VVal};
///
/// let genv = GlobalEnv::new_default();
///
/// genv.borrow_mut().set_var("xyz", &VVal::Int(31347));
///
/// let mut ctx = EvalContext::new(genv);
/// let ret = ctx.eval("xyz - 10").unwrap().i();
///
/// assert_eq!(ret, 31337);
///```
#[derive(Debug, Clone)]
pub struct EvalContext {
    /// Holds the reference to the supplied or internally created
    /// GlobalEnv.
    pub global:         GlobalEnvRef,
    local_compile:      Rc<RefCell<CompileEnv>>,
    /// Holds the top level environment data accross multiple eval()
    /// invocations.
    pub local:          Rc<RefCell<Env>>,
}

impl EvalContext {
    pub fn new(global: GlobalEnvRef) -> EvalContext {
        (Self::new_with_user_impl(global, Rc::new(RefCell::new(VVal::vec()))))
        .register_self_eval()
    }

    /// Creates a new EvalContext with an empty GlobalEnv.
    /// This means the EvalContext has none of the core or std library
    /// functions in it's global environment and you have to provide
    /// them yourself. Either by loading them from WLambda by `!@import std`
    /// or `!@wlambda`. Or by manually binding in the corresponding
    /// SymbolTable(s).
    ///
    ///```rust
    /// use wlambda::compiler::EvalContext;
    /// use wlambda::vval::{VVal, VValFun, Env};
    ///
    /// let mut ctx = EvalContext::new_empty_global_env();
    ///
    /// {
    ///     let mut genv = ctx.global.borrow_mut();
    ///     genv.set_module("wlambda", wlambda::prelude::core_symbol_table());
    ///     genv.import_module_as("wlambda", "");
    /// }
    ///
    /// assert_eq!(ctx.eval("type $true").unwrap().s_raw(), "bool")
    ///```
    #[allow(dead_code)]
    pub fn new_empty_global_env() -> EvalContext {
        Self::new_with_user_impl(
            GlobalEnv::new(),
            Rc::new(RefCell::new(VVal::vec())))
    }

    /// A shortcut: This creates a new EvalContext with a GlobalEnv::new_default()
    /// global environment.
    ///
    /// This is a shorthand for:
    ///```
    /// wlambda::compiler::EvalContext::new(
    ///     wlambda::compiler::GlobalEnv::new_default());
    ///```
    #[allow(dead_code)]
    pub fn new_default() -> EvalContext {
        Self::new(GlobalEnv::new_default())
    }

    fn register_self_eval(self) -> Self {
        let ctx_clone =
            Self::new_with_user_impl(
                self.global.clone(),
                self.local.borrow().get_user());

        self.global.borrow_mut().add_func("std:eval", move |env: &mut Env, _argc: usize| {
            let code    = env.arg(0).s_raw();
            let ctx     = ctx_clone.clone();
            let mut ctx = ctx.register_self_eval();
            match ctx.eval(&code) {
                Ok(v)  => Ok(v),
                Err(e) => Ok(env.new_err(format!("{}", e))),
            }
        }, Some(1), Some(2));

        self
    }

    pub fn get_exports(&self) -> SymbolTable {
        SymbolTable { symbols: self.local.borrow_mut().exports.clone() }
    }

    #[allow(dead_code)]
    fn new_with_user_impl(
        global: GlobalEnvRef, user: Rc<RefCell<dyn std::any::Any>>) -> EvalContext {

        EvalContext {
            global: global.clone(),
            local_compile: Rc::new(RefCell::new(CompileEnv {
                parent:    None,
                global: global.clone(),
                block_env: BlockEnv::new(),
                upvals:    Vec::new(),
                locals_space: 0,
                recent_var: String::new(),
                recent_sym: String::new(),
                implicit_arity: (ArityParam::Undefined, ArityParam::Undefined),
                explicit_arity: (ArityParam::Undefined, ArityParam::Undefined),
                quote_func: false,
            })),
            local: Rc::new(RefCell::new(Env::new_with_user(global, user))),
        }
    }

    #[allow(dead_code)]
    pub fn new_with_user(global: GlobalEnvRef, user: Rc<RefCell<dyn std::any::Any>>) -> EvalContext {
        (Self::new_with_user_impl(global, user)).register_self_eval()
    }

    /// Evaluates an AST of WLambda code and executes it with the given `EvalContext`.
    ///
    /// ```
    /// use wlambda::parser;
    /// let mut ctx = wlambda::EvalContext::new_default();
    ///
    /// let s = "$[1,2,3]";
    /// let ast = parser::parse(s, "somefilename").unwrap();
    /// let r = &mut ctx.eval_ast(&ast).unwrap();
    ///
    /// println!("Res: {}", r.s());
    /// ```
    pub fn eval_ast(&mut self, ast: &VVal) -> Result<VVal, EvalError>  {
        let prog = compile(ast, &mut self.local_compile);
        let local_env_size = self.local_compile.borrow().local_env_size();

        let env = self.local.borrow_mut();
        let mut res = Ok(VVal::Nul);

        std::cell::RefMut::map(env, |l_env| {
            res = match prog {
                Ok(prog_closures) => {
                    l_env.sp = 0;
                    l_env.set_bp(local_env_size);
                    match l_env.with_restore_sp(|e: &mut Env| { prog_closures(e) }) {
                        Ok(v)   => Ok(v),
                        Err(je) => Err(EvalError::ExecError(je)),
                    }
                },
                Err(e) => Err(EvalError::CompileError(e)),
            };
            l_env
        });

        res
    }

    /// Evaluates a WLambda code in a file with the given `EvalContext`.
    ///
    /// ```
    /// let mut ctx = wlambda::EvalContext::new_default();
    ///
    /// let r = &mut ctx.eval_file("examples/read_test.wl").unwrap();
    /// assert_eq!(r.i(), 403, "matches contents!");
    /// ```
    #[allow(dead_code)]
    pub fn eval_file(&mut self, filename: &str) -> Result<VVal, EvalError> {
        let contents = std::fs::read_to_string(filename);
        if let Err(err) = contents {
            Err(EvalError::IOError(filename.to_string(), err))
        } else {
            let contents = contents.unwrap();
            match parser::parse(&contents, filename) {
                Ok(ast) => self.eval_ast(&ast),
                Err(e)  => Err(EvalError::ParseError(e)),
            }
        }
    }

    /// Evaluates a piece of WLambda code with the given `EvalContext`.
    ///
    /// ```
    /// let mut ctx = wlambda::EvalContext::new_default();
    ///
    /// let r = &mut ctx.eval("$[1,2,3]").unwrap();
    /// println!("Res: {}", r.s());
    /// ```
    #[allow(dead_code)]
    pub fn eval(&mut self, s: &str) -> Result<VVal, EvalError>  {
        match parser::parse(s, "<wlambda::eval>") {
            Ok(ast) => self.eval_ast(&ast),
            Err(e)  => Err(EvalError::ParseError(e)),
        }
    }

    /// Evaluates a WLambda code with the corresponding filename
    /// in the given `EvalContext`.
    ///
    /// ```
    /// let mut ctx = wlambda::EvalContext::new_default();
    ///
    /// let r = &mut ctx.eval_string("403", "examples/read_test.wl").unwrap();
    /// assert_eq!(r.i(), 403, "matches contents!");
    /// ```
    #[allow(dead_code)]
    pub fn eval_string(&mut self, code: &str, filename: &str)
        -> Result<VVal, EvalError>
    {
        match parser::parse(code, filename) {
            Ok(ast) => self.eval_ast(&ast),
            Err(e)  => Err(EvalError::ParseError(e)),
        }
    }

    /// Calls a wlambda function with the given `EvalContext`.
    ///
    /// ```
    /// use wlambda::{VVal, EvalContext};
    /// let mut ctx = EvalContext::new_default();
    ///
    /// let returned_func = &mut ctx.eval("{ _ + _1 }").unwrap();
    /// assert_eq!(
    ///     ctx.call(returned_func,
    ///              &vec![VVal::Int(10), VVal::Int(11)]).unwrap().i(),
    ///     21);
    /// ```
    #[allow(dead_code)]
    pub fn call(&mut self, f: &VVal, args: &[VVal]) -> Result<VVal, StackAction>  {
        let mut env = self.local.borrow_mut();
        f.call(&mut env, args)
    }

    /// Sets a global variable for the scripts to access.
    ///
    /// ```
    /// use wlambda::{VVal, EvalContext};
    /// let mut ctx = EvalContext::new_default();
    ///
    /// ctx.set_global_var("XXX", &VVal::Int(200));
    ///
    /// assert_eq!(ctx.eval("XXX * 2").unwrap().i(), 400);
    /// ```
    #[allow(dead_code)]
    pub fn set_global_var(&mut self, var: &str, val: &VVal) {
        self.global.borrow_mut().set_var(var, val);
    }

    /// Gets the value of a global variable from the script:
    ///
    /// ```
    /// use wlambda::{VVal, EvalContext};
    /// let mut ctx = EvalContext::new_default();
    ///
    /// ctx.eval("!:global XXX = 22 * 2;");
    ///
    /// assert_eq!(ctx.get_global_var("XXX").unwrap().i(), 44);
    /// ```
    #[allow(dead_code)]
    pub fn get_global_var(&mut self, var: &str) -> Option<VVal> {
        self.global.borrow_mut().get_var(var)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum ArityParam {
    Undefined,
    Limit(usize),
    Infinite,
}

#[derive(Debug, Clone)]
struct BlockEnv {
    local_map_stack: std::vec::Vec<(usize, Box<std::collections::HashMap<String, VarPos>>)>,
    reuse_stk_slot: Rc<RefCell<std::vec::Vec<usize>>>,
    locals:          std::vec::Vec<(String, CompileLocal)>,
}

#[derive(Debug,Clone,Copy,PartialEq)]
#[repr(u8)]
pub enum ResValue {
    Nul,
    Ret,
    AccumVal,
    AccumFun,
    SelfObj,
    SelfData,
}

#[derive(Debug,Clone,Copy,PartialEq)]
#[repr(u8)]
pub enum ResPos {
    Local(u16),
    LocalRef(u16),
    Arg(u16),
    Up(u16),
    UpRef(u16),
    Global(u16),
    GlobalRef(u16),
    Data(u16),
    Stack(u16),
    Value(ResValue),
}

impl BlockEnv {
    fn new() -> Self {
        Self {
            local_map_stack: vec![(0, Box::new(std::collections::HashMap::new()))],
            locals:          vec![],
            reuse_stk_slot: Rc::new(RefCell::new(vec![])),
        }
    }

/*

    !x = $p(:Move, :Down);

    ?* x
        $p(:Move, pos) => {
            std:displayln "Moving to " pos;
        }
        $p(:Jump, strength) => {
            std:displayln "I Jumped: " strength;
        };

*/
    fn env_size(&self) -> usize {
        self.locals.len()
    }

    fn push_env(&mut self) {
        self.local_map_stack.push((0, Box::new(std::collections::HashMap::new())));
    }

    fn pop_env(&mut self) -> (usize, usize) {
        let block_env_vars = self.local_map_stack.pop().unwrap();

        let local_count = block_env_vars.0;
        for _ in 0..local_count {
            self.locals.pop();
        }

        (self.locals.len(), self.locals.len() + local_count)
    }

    fn set_upvalue(&mut self, var: &str, idx: usize) -> VarPos {
        let last_idx = self.local_map_stack.len() - 1;
        self.local_map_stack[last_idx].1
            .insert(String::from(var),
                    VarPos::UpValue(idx));
        VarPos::UpValue(idx)
    }

    fn next_local(&mut self) -> usize {
        let next_index = self.locals.len();
        self.locals.push((String::from(""), CompileLocal { }));
        next_index
    }

    fn def_local(&mut self, var: &str, idx: usize) {
        self.locals[idx].0 = String::from(var);
        let last_idx = self.local_map_stack.len() - 1;
        self.local_map_stack[last_idx].1
            .insert(String::from(var),
                    VarPos::Local(idx));
        self.local_map_stack[last_idx].0 += 1;
    }

    fn get(&self, var: &str) -> VarPos {
        for (_locals, map) in self.local_map_stack.iter().rev() {
            if let Some(pos) = map.get(var) {
                return pos.clone();
            }
        }

        VarPos::NoPos
    }
}

/// Compile time environment for allocating and
/// storing variables inside a function scope.
///
/// Also handles upvalues. Upvalues in WLambda are copied to every
/// scope that they are passed through until they are needed.
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CompileEnv {
    /// Reference to the global environment
    global:    GlobalEnvRef,
    /// Reference to the environment of the _parent_ function.
    parent:    Option<Rc<RefCell<CompileEnv>>>,
    /// Holds all function local variables and manages nesting of blocks.
    block_env: BlockEnv,
    /// Holds the maximum number of locals ever used:
    locals_space: usize,
    /// Stores position of the upvalues for copying the upvalues at runtime.
    upvals:    std::vec::Vec<VarPos>,
    /// Stores the implicitly calculated arity of this function.
    pub implicit_arity: (ArityParam, ArityParam),
    /// Stores the explicitly defined arity of this function.
    pub explicit_arity: (ArityParam, ArityParam),
    /// Recently accessed variable name:
    pub recent_var: String,
    /// Recently compiled symbol:
    pub recent_sym: String,
    /// If set, the next compile() is compiling a function as block.
    pub quote_func: bool,
}

/// Reference type to a `CompileEnv`.
type CompileEnvRef = Rc<RefCell<CompileEnv>>;

impl CompileEnv {
    pub fn new(g: GlobalEnvRef) -> Rc<RefCell<Self>> {
        Rc::new(RefCell::new(CompileEnv {
            parent:    None,
            global:    g,
            block_env: BlockEnv::new(),
            upvals:    Vec::new(),
            locals_space: 0,
            quote_func: false,
            recent_var: String::new(),
            recent_sym: String::new(),
            implicit_arity: (ArityParam::Undefined, ArityParam::Undefined),
            explicit_arity: (ArityParam::Undefined, ArityParam::Undefined),
        }))
    }

    pub fn create_env(parent: Option<CompileEnvRef>) -> Rc<RefCell<CompileEnv>> {
        let global = if let Some(p) = &parent {
            p.borrow_mut().global.clone()
        } else {
            GlobalEnv::new()
        };
        Rc::new(RefCell::new(CompileEnv {
            parent,
            global,
            block_env: BlockEnv::new(),
            upvals:    Vec::new(),
            locals_space: 0,
            recent_var: String::new(),
            recent_sym: String::new(),
            implicit_arity: (ArityParam::Undefined, ArityParam::Undefined),
            explicit_arity: (ArityParam::Undefined, ArityParam::Undefined),
            quote_func: false,
        }))
    }

    fn def_up(&mut self, s: &str, parent_local_var: VarPos) -> VarPos {
        let next_index = self.upvals.len();
        self.upvals.push(parent_local_var);
        self.block_env.set_upvalue(s, next_index)
    }

    pub fn def_const(&mut self, s: &str, val: VVal) {
        self.global.borrow_mut().env.insert(String::from(s), val);
    }

    pub fn def_local(&mut self, s: &str, idx: usize) {
        self.block_env.def_local(s, idx);
    }

    pub fn next_local(&mut self) -> usize {
        let idx = self.block_env.next_local();
        if (idx + 1) > self.locals_space {
            self.locals_space = idx + 1;
        }
        idx
    }

    pub fn get_local_space(&self) -> usize { self.locals_space }

    pub fn def(&mut self, s: &str, is_global: bool) -> VarPos {
        if is_global {
            let v = VVal::Nul;
            let r = v.to_ref();
            self.global.borrow_mut().env.insert(String::from(s), r.clone());
            VarPos::Global(r)
        } else {
            let idx = self.block_env.next_local();
            if (idx + 1) > self.locals_space {
                self.locals_space = idx + 1;
            }
            self.block_env.def_local(s, idx);
            VarPos::Local(idx)
        }
    }

    pub fn get_upval_pos(&self) -> std::vec::Vec<VarPos> {
        let mut poses = vec![];
        for p in self.upvals.iter() {
            match p {
                VarPos::UpValue(_) => poses.push(p.clone()),
                VarPos::Local(_)   => poses.push(p.clone()),
                VarPos::Global(_) => {
                    panic!("Globals can't be captured as upvalues!");
                },
                VarPos::Const(_) => {
                    panic!("Consts can't be captured as upvalues!");
                },
                VarPos::NoPos => poses.push(p.clone()),
            }
        }
        poses
    }

    pub fn local_env_size(&self) -> usize {
        self.block_env.env_size()
    }

    pub fn push_block_env(&mut self) {
        self.block_env.push_env();
    }

    pub fn pop_block_env(&mut self) -> (usize, usize) {
        self.block_env.pop_env()
    }

    pub fn get(&mut self, s: &str) -> VarPos {
        let pos = self.block_env.get(s);
        match pos {
            VarPos::NoPos => {
                let opt_p = self.parent.as_mut();
                if opt_p.is_none() {
                    if let Some(v) = self.global.borrow().env.get(s){
                        if v.is_ref() {
                            return VarPos::Global(v.clone());
                        } else {
                            return VarPos::Const(v.clone());
                        }
                    } else {
                        return VarPos::NoPos;
                    }
                }
                let parent = opt_p.unwrap().clone();
                let mut par_mut = parent.borrow_mut();

                let par_var_pos = par_mut.block_env.get(s);
                let par_var_pos = match par_var_pos {
                    VarPos::NoPos => par_mut.get(s),
                    _             => par_var_pos,
                };
                match par_var_pos {
                    VarPos::Local(_)   => self.def_up(s, par_var_pos),
                    VarPos::UpValue(_) => self.def_up(s, par_var_pos),
                    VarPos::Global(g)  => VarPos::Global(g),
                    VarPos::Const(c)   => VarPos::Const(c),
                    VarPos::NoPos      => VarPos::NoPos
                }
            }
            _ => pos.clone(),
        }
    }
}

fn compile_block(ast: &VVal, ce: &mut Rc<RefCell<CompileEnv>>) -> Result<EvalNode, CompileError> {
    let exprs : Vec<EvalNode> =
        ast.map_skip(|e| compile(e, ce), 1)?;

    #[allow(unused_assignments)]
    Ok(Box::new(move |e: &mut Env| {
        let mut res = VVal::Nul;
        for x in exprs.iter() {
            if let VVal::Err(ev) = res {
                return
                    Err(StackAction::panic_str(
                        format!("Error value dropped: {}", ev.borrow().0.s()),
                        Some(ev.borrow().1.clone())))
            }

            res = VVal::Nul;

            match x(e) {
                Ok(v)  => { res = v; },
                Err(e) => { return Err(e); },
            }
        }
        Ok(res)
    }))
}

pub fn set_impl_arity(i: usize, ce: &mut Rc<RefCell<CompileEnv>>) {
    let min = ce.borrow().implicit_arity.0.clone();
    match min {
        ArityParam::Undefined => { ce.borrow_mut().implicit_arity.0 = ArityParam::Limit(i); },
        ArityParam::Limit(j) => { if j < i { ce.borrow_mut().implicit_arity.0 = ArityParam::Limit(i); }; },
        _ => (),
    }

    let max = ce.borrow_mut().implicit_arity.1.clone();
    match max {
        ArityParam::Undefined => {
            ce.borrow_mut().implicit_arity.1 = ArityParam::Limit(i);
        },
        ArityParam::Limit(j) => {
            if j < i { ce.borrow_mut().implicit_arity.1 = ArityParam::Limit(i); }
        },
        _ => (),
    }
}

fn compile_var(ast: &VVal, ce: &mut Rc<RefCell<CompileEnv>>, to_ref: bool) -> Result<EvalNode, CompileError> {
    let var = ast.at(1).unwrap();
    var.with_s_ref(|var_s: &str| -> Result<EvalNode, CompileError> {
        if to_ref {
            match var_s {
                "_"  => { set_impl_arity(1,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(0).to_ref()) })) },
                "_1" => { set_impl_arity(2,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(1).to_ref()) })) },
                "_2" => { set_impl_arity(3,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(2).to_ref()) })) },
                "_3" => { set_impl_arity(4,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(3).to_ref()) })) },
                "_4" => { set_impl_arity(5,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(4).to_ref()) })) },
                "_5" => { set_impl_arity(6,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(5).to_ref()) })) },
                "_6" => { set_impl_arity(7,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(6).to_ref()) })) },
                "_7" => { set_impl_arity(8,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(7).to_ref()) })) },
                "_8" => { set_impl_arity(9,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(8).to_ref()) })) },
                "_9" => { set_impl_arity(10, ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(9).to_ref()) })) },
                "@"  => {
                    ce.borrow_mut().implicit_arity.1 = ArityParam::Infinite;
                    Ok(Box::new(move |e: &mut Env| { Ok(e.argv().to_ref()) }))
                },
                _ => {
                    let pos = ce.borrow_mut().get(var_s);
                    match pos {
                        VarPos::UpValue(i) =>
                            Ok(Box::new(move |e: &mut Env| { Ok(e.get_up_captured_ref(i)) })),
                        VarPos::Local(i) =>
                            Ok(Box::new(move |e: &mut Env| { Ok(e.get_local_captured_ref(i)) })),
                        VarPos::Global(v) =>
                            Ok(Box::new(move |_e: &mut Env| { Ok(v.clone()) })),
                        VarPos::Const(v) =>
                            Ok(Box::new(move |_e: &mut Env| { Ok(v.clone().to_ref()) })),
                        VarPos::NoPos => {
                            ast.to_compile_err(
                                format!("Variable '{}' undefined", var_s))
                        }
                    }
                }
            }
        } else {
            match var_s {
                "_"  => { set_impl_arity(1,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(0)) })) },
                "_1" => { set_impl_arity(2,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(1)) })) },
                "_2" => { set_impl_arity(3,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(2)) })) },
                "_3" => { set_impl_arity(4,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(3)) })) },
                "_4" => { set_impl_arity(5,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(4)) })) },
                "_5" => { set_impl_arity(6,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(5)) })) },
                "_6" => { set_impl_arity(7,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(6)) })) },
                "_7" => { set_impl_arity(8,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(7)) })) },
                "_8" => { set_impl_arity(9,  ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(8)) })) },
                "_9" => { set_impl_arity(10, ce); Ok(Box::new(move |e: &mut Env| { Ok(e.arg(9)) })) },
                "@"  => {
                    ce.borrow_mut().implicit_arity.1 = ArityParam::Infinite;
                    Ok(Box::new(move |e: &mut Env| { Ok(e.argv()) }))
                },
                _ => {
                    let pos = ce.borrow_mut().get(var_s);
                    match pos {
                        VarPos::UpValue(i) =>
                            Ok(Box::new(move |e: &mut Env| { Ok(e.get_up(i)) })),
                        VarPos::Local(i) =>
                            Ok(Box::new(move |e: &mut Env| { Ok(e.get_local(i)) })),
                        VarPos::Global(v) =>
                            Ok(Box::new(move |_e: &mut Env| { Ok(v.deref()) })),
                        VarPos::Const(v) =>
                            Ok(Box::new(move |_e: &mut Env| { Ok(v.clone()) })),
                        VarPos::NoPos => {
                            ast.to_compile_err(
                                format!("Variable '{}' undefined", var_s))
                        }
                    }
                }
            }
        }
    })
}

pub fn check_for_at_arity(prev_arity: (ArityParam, ArityParam), ast: &VVal, ce: &mut Rc<RefCell<CompileEnv>>, vars: &VVal) {
    // If we have an destructuring assignment directly from "@", then we conclude
    // the implicit max arity to be minimum of number of vars:
    if ast.at(2).unwrap_or(VVal::Nul).at(0).unwrap_or(VVal::Nul).get_syn() == Syntax::Var {
        if let VVal::Lst(l) = vars {
            let llen = l.borrow().len();

            let var = ast.at(2).unwrap().at(1).unwrap();
            if var.with_s_ref(|var: &str| var == "@") {
                ce.borrow_mut().implicit_arity = prev_arity;
                set_impl_arity(llen, ce);
            }
        }
    }
}

fn compile_const_value(val: &VVal) -> Result<VVal, CompileError> {
    match val {
        VVal::Lst(l) => {
            let l = l.borrow();
            match l[0].get_syn() {
                Syntax::Key => Ok(l[1].clone()),
                Syntax::Str => Ok(l[1].clone()),
                Syntax::Lst => {
                    let v = VVal::vec();
                    for i in l.iter().skip(1) {
                        v.push(compile_const_value(i)?);
                    }
                    Ok(v)
                },
                Syntax::Map => {
                    let m = VVal::map();
                    for i in l.iter().skip(1) {
                        let key = compile_const_value(&i.at(0).unwrap_or(VVal::Nul))?;
                        let val = compile_const_value(&i.at(1).unwrap_or(VVal::Nul))?;
                        m.set_key_mv(key.s_raw(), val);
                    }
                    Ok(m)
                },
                _ => Err(val.to_compile_err(
                    format!(
                        "Invalid literal in constant definition: {}",
                        val.s())).err().unwrap()),
            }
        },
        _ => Ok(val.clone()),
    }
}

fn compile_const(ast: &VVal, ce: &mut Rc<RefCell<CompileEnv>>) -> Result<EvalNode, CompileError> {
    let vars    = ast.at(1).unwrap();
    let value   = ast.at(2).unwrap();
    let destr   = ast.at(3).unwrap_or(VVal::Nul);

    if destr.b() {
        for (i, (v, _)) in vars.iter().enumerate() {
            let varname = v.s_raw();
            let val = compile_const_value(&value)?;
            let val =
                match val {
                    VVal::Lst(_) => val.at(i).unwrap_or(VVal::Nul),
                    VVal::Map(_) => val.get_key(&varname).unwrap_or(VVal::Nul),
                    _ => val,
                };

            ce.borrow_mut().def_const(&varname, val);
        }
    } else {
        let varname = vars.at(0).unwrap().s_raw();
        let const_val = compile_const_value(&value)?;
        ce.borrow_mut().def_const(&varname, const_val);
    }

    Ok(Box::new(move |_e: &mut Env| { Ok(VVal::Nul) }))
}

fn compile_def(ast: &VVal, ce: &mut Rc<RefCell<CompileEnv>>, is_global: bool) -> Result<EvalNode, CompileError> {
    let prev_max_arity = ce.borrow().implicit_arity.clone();

    let vars    = ast.at(1).unwrap();
    let value   = ast.at(2).unwrap();
    let destr   = ast.at(3).unwrap_or(VVal::Nul);

    //d// println!("COMP DEF: {:?} global={}, destr={}", vars, is_global, destr.b());

    if destr.b() {
        let cv = compile(&value, ce)?;

        check_for_at_arity(prev_max_arity, ast, ce, &vars);

        let poses =
            vars.map_ok_skip(
                |v| ce.borrow_mut().def(&v.s_raw(), is_global),
                0);

        Ok(Box::new(move |e: &mut Env| {
            let v = cv(e)?;
            
            match set_consume_at_varposes_from_vval(e, v, &poses, &vars) {
                Ok(_) => Ok(VVal::Nul),

                // the set_consume_at_varpos that the above function is generated from can't err
                Err(_) => unreachable!(),
            }
        }))
    } else {
        let varname = vars.at(0).unwrap().s_raw();
        ce.borrow_mut().recent_var = varname.clone();
        let cv = compile(&value, ce)?;

        let pos = ce.borrow_mut().def(&varname, is_global);

        match pos {
            VarPos::Local(vip) => {
                Ok(Box::new(move |e: &mut Env| {
                    let v = cv(e)?;
                    e.set_consume(vip, v);
                    Ok(VVal::Nul)
                }))
            },
            VarPos::Global(r) => {
                let gref = r;
                Ok(Box::new(move |e: &mut Env| {
                    gref.set_ref(cv(e)?);
                    Ok(VVal::Nul)
                }))
            },
            _ => ast.to_compile_err(
                    "Can't define badly positioned variable!".to_string()),
        }
    }
}

enum SetVarPosErr {
    ConstantAssignment,
    GlobalReadOnlyAssignment,
    UnknownPosFor(String),
}
impl Display for SetVarPosErr {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        use SetVarPosErr::*;
        match self {
            ConstantAssignment       => write!(f, "Can't assign to constant!"),
            GlobalReadOnlyAssignment => write!(f, "Can't assign to global read only variable!"),
            UnknownPosFor(v)         => write!(f, "Unknown pos to assign value '{}' to!", v),
        }
    }
}

fn set_ref_at_varpos(e: &mut Env, pos: &VarPos, rv: &VVal) -> Result<(), SetVarPosErr> {
    let v = rv.clone();
    match pos {
        VarPos::UpValue(d)           => e.assign_ref_up(*d, v),
        VarPos::Local(d)             => e.assign_ref_local(*d, v),
        VarPos::Global(VVal::Ref(r)) => { r.borrow().set_ref(v); },
        VarPos::Global(_)            => Err(SetVarPosErr::GlobalReadOnlyAssignment)?,
        VarPos::Const(_)             => Err(SetVarPosErr::ConstantAssignment)?,
        VarPos::NoPos                => Err(SetVarPosErr::UnknownPosFor(v.s()))?,
    }

    Ok(())
}

fn set_env_at_varpos(e: &mut Env, pos: &VarPos, v: &VVal) -> Result<(), SetVarPosErr> {
    match pos {
        VarPos::UpValue(d)           => e.set_up(*d, v.clone()),
        VarPos::Local(d)             => e.set_consume(*d, v.clone()),
        VarPos::Global(VVal::Ref(r)) => { r.replace(v.clone()); },
        VarPos::Global(_)            => Err(SetVarPosErr::GlobalReadOnlyAssignment)?,
        VarPos::Const(_)             => Err(SetVarPosErr::ConstantAssignment)?,
        VarPos::NoPos                => Err(SetVarPosErr::UnknownPosFor(v.s()))?,
    }

    Ok(())
}

fn set_consume_at_varpos(e: &mut Env, pos: &VarPos, val: &VVal) -> Result<(), SetVarPosErr> {
    let v = val.clone();
    match pos {
        VarPos::Local(vip)            => e.set_consume(*vip, v),
        VarPos::Global(VVal::Ref(gr)) => { gr.replace(v); },
        _                             => {}
    }

    Ok(())
}

macro_rules! set_varposes_from_vval { ($fn:ident, $set_fn:ident) => {
    fn $fn(e: &mut Env, v: VVal, poses: &Vec<VarPos>, vars: &VVal) -> Result<(), SetVarPosErr> {
        match v {
            VVal::Lst(lst) => {
                let l = lst.borrow();
                for (i, pos) in poses.iter().enumerate() {
                    let n = VVal::Nul;
                    let val = l.get(i).unwrap_or(&n);
                    $set_fn(e, pos, val)?;
                }
            },
            VVal::Map(map) => {
                let m = map.borrow();
                for (i, pos) in poses.iter().enumerate() {
                    let n = VVal::Nul;
                    let val = m.get(&vars.at(i).unwrap().s_raw()).unwrap_or(&n);
                    $set_fn(e, pos, val)?;
                }
            },
            VVal::Pair(p) => {
                let (lv, rv) = *p;
                if let Some(pos) = poses.get(0) {
                    $set_fn(e, pos, &lv)?;
                }
                if let Some(pos) = poses.get(1) {
                    $set_fn(e, pos, &rv)?;
                }
            },
            _ => {
                for pos in poses.iter() {
                    $set_fn(e, pos, &v)?;
                }
            }
        }
        Ok(())
    }
} }
set_varposes_from_vval!( set_ref_at_varposes_from_vval     , set_ref_at_varpos );
set_varposes_from_vval!( set_env_at_varposes_from_vval     , set_env_at_varpos );
set_varposes_from_vval!( set_consume_at_varposes_from_vval , set_consume_at_varpos );

fn compile_assign(ast: &VVal, ce: &mut Rc<RefCell<CompileEnv>>, is_ref: bool) -> Result<EvalNode, CompileError> {
    let prev_max_arity = ce.borrow().implicit_arity.clone();

    let syn  = ast.at(0).unwrap_or(VVal::Nul);
    let spos = syn.get_syn_pos();

    let vars    = ast.at(1).unwrap();
    let value   = ast.at(2).unwrap();
    let destr   = ast.at(3).unwrap_or(VVal::Nul);
    let cv      = compile(&value, ce)?;

    if destr.b() {
        check_for_at_arity(prev_max_arity, ast, ce, &vars);

        let poses = vars.map_ok_skip(|v| ce.borrow_mut().get(&v.s_raw()), 0);

        for (i, pos) in poses.iter().enumerate() {
            if let VarPos::NoPos = pos {
                return 
                    ast.to_compile_err(
                        format!("Can't assign to undefined local variable '{}'",
                                vars.at(i).unwrap_or(VVal::Nul).s_raw()));
            }
        }

        if is_ref {
            Ok(Box::new(move |e: &mut Env| {
                let v = cv(e)?;

                match set_ref_at_varposes_from_vval(e, v, &poses, &vars) {
                    Err(e) => Err(StackAction::panic_str(format!("{}", e), Some(spos.clone()))),
                    Ok(_) => Ok(VVal::Nul)
                }
            }))
        } else {
            Ok(Box::new(move |e: &mut Env| {
                let v = cv(e)?;

                match set_env_at_varposes_from_vval(e, v, &poses, &vars) {
                    Err(e) => Err(StackAction::panic_str(format!("{}", e), Some(spos.clone()))),
                    Ok(_) => Ok(VVal::Nul)
                }
            }))
        }

    } else {
        let s   = &vars.at(0).unwrap().s_raw();
        let pos = ce.borrow_mut().get(s);

        if is_ref {
            match pos {
                VarPos::UpValue(i) => {
                    Ok(Box::new(move |e: &mut Env| {
                        let v = cv(e)?;
                        e.assign_ref_up(i, v);
                        Ok(VVal::Nul)
                    }))
                },
                VarPos::Local(i) => {
                    Ok(Box::new(move |e: &mut Env| {
                        let v = cv(e)?;
                        e.assign_ref_local(i, v);
                        Ok(VVal::Nul)
                    }))
                },
                VarPos::Global(glob_v) => {
                    if let VVal::Ref(glob_r) = glob_v {
                        Ok(Box::new(move |e: &mut Env| {
                            let v = cv(e)?;
                            glob_r.borrow().set_ref(v);
                            Ok(VVal::Nul)
                        }))
                    } else {
                        ast.to_compile_err(
                            format!("Can't assign to read only global variable '{}'",
                                    s))
                    }
                },
                VarPos::Const(_) =>
                    ast.to_compile_err(
                        format!("Can't assign to constant '{}'", s)),
                VarPos::NoPos =>
                    ast.to_compile_err(
                        format!("Can't assign to undefined local variable '{}'", s)),
            }
        } else {
            match pos {
                VarPos::UpValue(i) => {
                    Ok(Box::new(move |e: &mut Env| {
                        let v = cv(e)?;
                        e.set_up(i, v);
                        Ok(VVal::Nul)
                    }))
                },
                VarPos::Local(i) => {
                    Ok(Box::new(move |e: &mut Env| {
                        let v = cv(e)?;
                        e.set_consume(i, v);
                        Ok(VVal::Nul)
                    }))
                },
                VarPos::Global(glob_v) => {
                    if let VVal::Ref(glob_r) = glob_v {
                        Ok(Box::new(move |e: &mut Env| {
                            let v = cv(e)?;
                            glob_r.replace(v);
                            Ok(VVal::Nul)
                        }))
                    } else {
                        ast.to_compile_err(
                            format!("Can't assign to read only global variable '{}'",
                                    s))
                    }
                },
                VarPos::Const(_) =>
                    ast.to_compile_err(
                        format!("Can't assign to constant '{}'", s)),
                VarPos::NoPos =>
                    ast.to_compile_err(
                        format!("Can't assign to undefined local variable '{}'", s)),
            }
        }
    }
}

#[inline]
pub fn check_error_value(v: VVal, at: &str) -> Result<VVal, StackAction> {
    if let VVal::Err(ev) = v {
        return
            Err(StackAction::panic_str(
                format!("Error value in {}: {}", at, ev.borrow().0.s()),
                Some(ev.borrow().1.clone())))
    }
    Ok(v)
}

// Optimizes a.b -> b[a] conversions.
fn generate_get_key(map: EvalNode, idx: EvalNode, spos: SynPos, method: bool)
    -> EvalNode
{
    if method {
        Box::new(move |e: &mut Env| {
            let m = map(e)?;
            let s = check_error_value(idx(e)?, "field idx/key")?;
            match s {
                VVal::Int(i)  => Ok(m.at(i as usize).unwrap_or(VVal::Nul)),
                VVal::Bol(b)  => Ok(m.at(b as usize).unwrap_or(VVal::Nul)),
                VVal::Sym(sy) => Ok(m.proto_lookup(&sy.borrow()).unwrap_or(VVal::Nul)),
                VVal::Str(sy) => Ok(m.proto_lookup(&sy.borrow()).unwrap_or(VVal::Nul)),
                _ => {
                    e.push(m.clone());
                    let ret = s.call_internal(e, 1);
                    e.pop();
                    if let Err(sa) = ret {
                        Err(sa.wrap_panic(Some(spos.clone())))
                    } else {
                        ret
                    }
                }
            }
        })
    } else {
        Box::new(move |e: &mut Env| {
            let m = map(e)?;
            let s = check_error_value(idx(e)?, "field idx/key")?;
            match s {
                VVal::Int(i)  => Ok(m.at(i as usize).unwrap_or(VVal::Nul)),
                VVal::Bol(b)  => Ok(m.at(b as usize).unwrap_or(VVal::Nul)),
                VVal::Sym(sy) => Ok(m.get_key(&sy.borrow()).unwrap_or(VVal::Nul)),
                VVal::Str(sy) => Ok(m.get_key(&sy.borrow()).unwrap_or(VVal::Nul)),
                _ => {
                    e.push(m.clone());
                    let ret = s.call_internal(e, 1);
                    e.pop();
                    if let Err(sa) = ret {
                        Err(sa.wrap_panic(Some(spos.clone())))
                    } else {
                        ret
                    }
                }
            }
        })
    }
}

fn generate_call(func: EvalNode,
                 call_args: Vec<EvalNode>,
                 spos: SynPos)
    -> EvalNode
{
    let argc = call_args.len();

    match argc {
        0 => (Box::new(move |e: &mut Env| {
            let f = func(e)?;
            let ret = f.call_no_args(e);
            if let Err(sa) = ret {
                Err(sa.wrap_panic(Some(spos.clone())))
            } else {
                ret
            }
        })),
        1 => (Box::new(move |e: &mut Env| {
            let f = func(e)?;

            let v = call_args[0](e)?;
            e.push(v);
            let ret = f.call_internal(e, 1);
            e.pop();
            if let Err(sa) = ret {
                Err(sa.wrap_panic(Some(spos.clone())))
            } else {
                ret
            }
        })),
        2 => (Box::new(move |e: &mut Env| {
            let f = func(e)?;

            let v = call_args[0](e)?;
            let v1 = call_args[1](e)?;
            e.push(v);
            e.push(v1);

            let ret = f.call_internal(e, 2);
            e.popn(2);
            if let Err(sa) = ret {
                Err(sa.wrap_panic(Some(spos.clone())))
            } else {
                ret
            }
        })),
        3 => (Box::new(move |e: &mut Env| {
            let f = func(e)?;

            let v = call_args[0](e)?;
            let v1 = call_args[1](e)?;
            let v2 = call_args[2](e)?;
            e.push(v);
            e.push(v1);
            e.push(v2);

            let ret = f.call_internal(e, 3);
            e.popn(3);
            if let Err(sa) = ret {
                Err(sa.wrap_panic(Some(spos.clone())))
            } else {
                ret
            }
        })),
        4 => (Box::new(move |e: &mut Env| {
            let f = func(e)?;

            let v = call_args[0](e)?;
            let v1 = call_args[1](e)?;
            let v2 = call_args[2](e)?;
            let v3 = call_args[3](e)?;
            e.push(v);
            e.push(v1);
            e.push(v2);
            e.push(v3);

            let ret = f.call_internal(e, 4);
            e.popn(4);
            if let Err(sa) = ret {
                Err(sa.wrap_panic(Some(spos.clone())))
            } else {
                ret
            }
        })),
        5 => (Box::new(move |e: &mut Env| {
            let f = func(e)?;

            let v = call_args[0](e)?;
            let v1 = call_args[1](e)?;
            let v2 = call_args[2](e)?;
            let v3 = call_args[3](e)?;
            let v4 = call_args[4](e)?;
            e.push(v);
            e.push(v1);
            e.push(v2);
            e.push(v3);
            e.push(v4);

            let ret = f.call_internal(e, 5);
            e.popn(5);
            if let Err(sa) = ret {
                Err(sa.wrap_panic(Some(spos.clone())))
            } else {
                ret
            }
        })),
        6 => (Box::new(move |e: &mut Env| {
            let f = func(e)?;

            let v = call_args[0](e)?;
            let v1 = call_args[1](e)?;
            let v2 = call_args[2](e)?;
            let v3 = call_args[3](e)?;
            let v4 = call_args[4](e)?;
            let v5 = call_args[5](e)?;
            e.push(v);
            e.push(v1);
            e.push(v2);
            e.push(v3);
            e.push(v4);
            e.push(v5);

            let ret = f.call_internal(e, 6);
            if let Err(sa) = ret {
                Err(sa.wrap_panic(Some(spos.clone())))
            } else {
                ret
            }
        })),
        _ => (Box::new(move |e: &mut Env| {
            let f    = func(e)?;

            for x in call_args.iter() {
                let v = x(e)?;
                e.push(v);
            }
            let ret = f.call_internal(e, argc);
            e.popn(argc);
            if let Err(sa) = ret {
                Err(sa.wrap_panic(Some(spos.clone())))
            } else {
                ret
            }
        }))
    }
}

fn fetch_object_key_access(ast: &VVal) -> Option<(Syntax, VVal, VVal)> {
    let syn = ast.v_(0).get_syn();
    match syn {
        Syntax::GetKey => {
            Some((Syntax::GetKey, ast.v_(1), ast.v_(2)))
        },
        Syntax::GetKey2 => {
            let mut get_obj = ast.shallow_clone();
            get_obj.set_syn_at(0, Syntax::GetKey);
            let key = get_obj.pop();
            Some((Syntax::GetKey, get_obj, key))
        },
        Syntax::GetKey3 => {
            let mut get_obj = ast.shallow_clone();
            get_obj.set_syn_at(0, Syntax::GetKey2);
            let key = get_obj.pop();
            Some((Syntax::GetKey, get_obj, key))
        },
        Syntax::GetSym => {
            Some((Syntax::GetSym, ast.v_(1), ast.v_(2)))
        },
        Syntax::GetSym2 => {
            let mut get_obj = ast.shallow_clone();
            get_obj.set_syn_at(0, Syntax::GetSym);
            let key = get_obj.pop();
            Some((Syntax::GetSym, get_obj, key))
        },
        Syntax::GetSym3 => {
            let mut get_obj = ast.shallow_clone();
            get_obj.set_syn_at(0, Syntax::GetSym2);
            let key = get_obj.pop();
            Some((Syntax::GetSym, get_obj, key))
        },
        _ => None,
    }
}

pub fn copy_upvs(upvs: &[VarPos], e: &mut Env, upvalues: &mut std::vec::Vec<VVal>) {
    for u in upvs.iter() {
        match u {
            VarPos::UpValue(i) => upvalues.push(e.get_up_raw(*i)),
            VarPos::Local(i)   => upvalues.push(e.get_local_up_promotion(*i)),
            VarPos::NoPos      => upvalues.push(VVal::Nul.to_ref()),
            VarPos::Global(_)  => (),
            VarPos::Const(_)   => (),
        }
    }
}

fn compile_block_env(ast: &VVal, ce: &mut Rc<RefCell<CompileEnv>>)
    -> Result<EvalNode, CompileError>
{
    ce.borrow_mut().push_block_env();
    let block = compile(ast, ce)?;
    let block_env_var_count = ce.borrow_mut().pop_block_env();
    let block_env_var_count = block_env_var_count.1 - block_env_var_count.0;

    Ok(Box::new(move |e: &mut Env| {
        for i in 0..block_env_var_count {
            e.push(VVal::Nul);
        }
        let res = block(e);
        e.popn(block_env_var_count);
        res
    }))
}

pub fn compile(ast: &VVal, ce: &mut Rc<RefCell<CompileEnv>>) -> Result<EvalNode, CompileError> {
    let quote_func = ce.borrow_mut().quote_func;
    ce.borrow_mut().quote_func = false;
    match ast {
        VVal::Lst(l) => {
            let syn  = ast.at(0).unwrap_or(VVal::Nul);
            let spos = syn.get_syn_pos();
            let syn  = syn.get_syn();

            match syn {
                Syntax::Block       => { compile_block(ast, ce)         },
                Syntax::Var         => { compile_var(ast, ce, false)    },
                Syntax::Def         => { compile_def(ast, ce, false)    },
                Syntax::DefGlobRef  => { compile_def(ast, ce, true)     },
                Syntax::DefConst    => { compile_const(ast, ce)         },
                Syntax::Assign      => { compile_assign(ast, ce, false) },
                Syntax::AssignRef   => { compile_assign(ast, ce, true)  },
                Syntax::IVec        => {
                    use crate::nvec::NVec;
                    let lc = l
                        .borrow()
                        .iter()
                        .map(|v| compile(v, ce))
                        .collect::<Result<Vec<_>, CompileError>>()?;

                    Ok(Box::new(move |e: &mut Env| {
                        let mut c = lc.iter().map(|f| f(e).map(|v| v.i()));
                        let _ = c.next();
                        Ok(VVal::IVec(match (c.next(), c.next(), c.next(), c.next()) {
                            (Some(x), Some(y), None   , None)    => NVec::Vec2(x?, y?),
                            (Some(x), Some(y), Some(z), None)    => NVec::Vec3(x?, y?, z?),
                            (Some(x), Some(y), Some(z), Some(w)) => NVec::Vec4(x?, y?, z?, w?),
                            _ => return Err(
                                StackAction::panic_str(
                                    "Cannot create an IVector without between 2 and 4 (inclusive) integers."
                                        .to_string(),
                                    Some(spos.clone()),
                                ),
                            )
                        }))
                    }))
                },
                Syntax::FVec        => {
                    use crate::nvec::NVec;
                    let lc = l
                        .borrow()
                        .iter()
                        .map(|v| compile(v, ce))
                        .collect::<Result<Vec<_>, CompileError>>()?;

                    Ok(Box::new(move |e: &mut Env| {
                        let mut c = lc.iter().map(|f| f(e).map(|v| v.f()));
                        let _ = c.next();
                        Ok(VVal::FVec(match (c.next(), c.next(), c.next(), c.next()) {
                            (Some(x), Some(y), None   , None)    => NVec::Vec2(x?, y?),
                            (Some(x), Some(y), Some(z), None)    => NVec::Vec3(x?, y?, z?),
                            (Some(x), Some(y), Some(z), Some(w)) => NVec::Vec4(x?, y?, z?, w?),
                            _ => return Err(
                                StackAction::panic_str(
                                    "Cannot create an IVector without between 2 and 4 (inclusive) integers."
                                        .to_string(),
                                    Some(spos.clone()),
                                ),
                            )
                        }))
                    }))
                },
                Syntax::SelfObj => {
                    Ok(Box::new(move |e: &mut Env| { Ok(e.self_object()) }))
                },
                Syntax::SelfData => {
                    Ok(Box::new(move |e: &mut Env| { Ok(e.self_object().proto_data()) }))
                },
                Syntax::Accum => {
                    match ast.at(1) {
                        Some(s) => {
                            match &s.s_raw()[..] {
                                "string" => {
                                    let ex = compile(&ast.at(2).unwrap(), ce)?;
                                    Ok(Box::new(move |e: &mut Env| {
                                        e.with_accum(
                                            VVal::new_str(""),
                                            |e: &mut Env| Ok(ex(e)?))
                                    }))
                                },
                                "bytes" => {
                                    let ex = compile(&ast.at(2).unwrap(), ce)?;
                                    Ok(Box::new(move |e: &mut Env| {
                                        e.with_accum(
                                            VVal::new_byt(vec![]),
                                            |e: &mut Env| Ok(ex(e)?))
                                    }))
                                },
                                "float" => {
                                    let ex = compile(&ast.at(2).unwrap(), ce)?;
                                    Ok(Box::new(move |e: &mut Env| {
                                        e.with_accum(
                                            VVal::Flt(0.0),
                                            |e: &mut Env| Ok(ex(e)?))
                                    }))
                                },
                                "int" => {
                                    let ex = compile(&ast.at(2).unwrap(), ce)?;
                                    Ok(Box::new(move |e: &mut Env| {
                                        e.with_accum(
                                            VVal::Int(0),
                                            |e: &mut Env| Ok(ex(e)?))
                                    }))
                                },
                                "map" => {
                                    let ex = compile(&ast.at(2).unwrap(), ce)?;
                                    Ok(Box::new(move |e: &mut Env| {
                                        e.with_accum(
                                            VVal::map(),
                                            |e: &mut Env| Ok(ex(e)?))
                                    }))
                                },
                                "vec" => {
                                    let ex = compile(&ast.at(2).unwrap(), ce)?;
                                    Ok(Box::new(move |e: &mut Env| {
                                        e.with_accum(
                                            VVal::vec(),
                                            |e: &mut Env| Ok(ex(e)?))
                                    }))
                                },
                                "@" => {
                                    Ok(Box::new(move |e: &mut Env| {
                                        Ok(e.get_accum_value())
                                    }))
                                },
                                _ => {
                                    panic!("COMPILER ERROR: BAD ACCUM SYM");
                                }
                            }
                        },
                        None => {
                            Ok(Box::new(move |e: &mut Env|
                                Ok(e.get_accum_function())))
                        }
                    }
                },
                Syntax::Import => {
                    let prefix = ast.at(1).unwrap();
                    let name   = ast.at(2).unwrap();
                    let s_prefix = if prefix.is_none() { String::from("") }
                                   else { prefix.s_raw() + ":" };

                    let glob_ref = ce.borrow_mut().global.clone();
                    {
                        let mut gr = glob_ref.borrow_mut();
                        let mm = gr.mem_modules.clone();
                        let e  = &mut gr.env;
                        let hm = &mm.borrow();
                        let mod_name = name.s_raw();

                        if let Some(stbl) = hm.get(&mod_name) {
                            for (k, v) in &stbl.symbols {
                                e.insert(s_prefix.clone() + &k, v.clone());
                            }
                            return Ok(Box::new(move |_e: &mut Env| { Ok(VVal::Nul) }));
                        }
                    }

                    let resolver : Option<Rc<RefCell<dyn ModuleResolver>>> =
                        glob_ref.borrow_mut().resolver.clone();

                    let path : Vec<String> =
                        (&name.s_raw())
                            .split(':')
                            .map(String::from)
                            .collect();

                    let import_file_path = if spos.file.s() == "?" { None } else { Some(spos.file.s()) };

                    if let Some(resolver) = resolver {

                        let r = resolver.borrow();
                        let exports = r.resolve(glob_ref.clone(), &path, import_file_path);
                        match exports {
                            Err(ModuleLoadError::NoSuchModule(p)) => {
                                ast.to_compile_err(
                                    format!("Couldn't find module '{}' in paths: {}", name.s_raw(), p))
                            },
                            Err(ModuleLoadError::ModuleEvalError(e)) => {
                                ast.to_compile_err(
                                    format!("Error on evaluating module '{}': {}", name.s_raw(), e))
                            },
                            Err(ModuleLoadError::Other(s)) => {
                                ast.to_compile_err(
                                    format!("Error on resolving module '{}': {}", name.s_raw(), s))
                            },
                            Ok(symtbl) => {
                                for (k, v) in symtbl.symbols {
                                    glob_ref.borrow_mut().env.insert(
                                        s_prefix.clone() + &k, v.clone());
                                }

                                Ok(Box::new(move |_e: &mut Env| { Ok(VVal::Nul) }))
                            },
                        }
                    } else {
                        ast.to_compile_err(
                            format!("Couldn't resolve module '{}'", name.s_raw()))
                    }
                },
                Syntax::DumpStack => {
                    Ok(Box::new(move |e: &mut Env| {
                        println!("DUMPSTACK@{}", spos);
                        e.dump_stack();
                        Ok(VVal::Nul)
                    }))
                },
                Syntax::Export => {
                    let name = ast.at(1).unwrap();
                    let val = compile(&ast.at(2).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        let value = val(e)?;
                        e.export_name(&name.s_raw(), &value);
                        Ok(value)
                    }))
                },
                Syntax::Err => {
                    let err_val = compile(&ast.at(1).unwrap(), ce)?;
                    Ok(Box::new(move |e: &mut Env|
                        Ok(VVal::err(err_val(e)?, spos.clone()))))
                },
                Syntax::Key => {
                    let sym = ast.at(1).unwrap();
                    ce.borrow_mut().recent_sym = sym.s_raw();
                    Ok(Box::new(move |_: &mut Env| Ok(sym.clone())))
                },
                Syntax::Str => {
                    let s = ast.at(1).unwrap();
                    ce.borrow_mut().recent_sym = s.s_raw();
                    Ok(Box::new(move |_: &mut Env| Ok(s.clone())))
                },
                Syntax::GetIdx => {
                    let map = compile(&ast.at(1).unwrap(), ce)?;
                    let idx = ast.at(2).unwrap().i();

                    Ok(Box::new(move |e: &mut Env| {
                        let m = map(e)?;
                        Ok(m.at(idx as usize).unwrap_or(VVal::Nul))
                    }))
                },
                Syntax::GetIdx2 => {
                    let map = compile(&ast.at(1).unwrap(), ce)?;
                    let idx = ast.at(2).unwrap().i();
                    let idx2 = ast.at(3).unwrap().i();

                    Ok(Box::new(move |e: &mut Env| {
                        let m = map(e)?;
                        Ok(m.at(idx as usize).unwrap_or(VVal::Nul)
                            .at(idx2 as usize).unwrap_or(VVal::Nul))
                    }))
                },
                Syntax::GetIdx3 => {
                    let map = compile(&ast.at(1).unwrap(), ce)?;
                    let idx = ast.at(2).unwrap().i();
                    let idx2 = ast.at(3).unwrap().i();
                    let idx3 = ast.at(4).unwrap().i();

                    Ok(Box::new(move |e: &mut Env| {
                        let m = map(e)?;
                        Ok(m.at(idx as usize).unwrap_or(VVal::Nul)
                            .at(idx2 as usize).unwrap_or(VVal::Nul)
                            .at(idx3 as usize).unwrap_or(VVal::Nul))
                    }))
                },
                Syntax::GetSym => {
                    let map = compile(&ast.at(1).unwrap(), ce)?;
                    let sym = ast.at(2).unwrap().s_raw();

                    Ok(Box::new(move |e: &mut Env| {
                        let m = map(e)?;
                        Ok(m.get_key(&sym).unwrap_or(VVal::Nul))
                    }))
                },
                Syntax::GetSym2 => {
                    let map = compile(&ast.at(1).unwrap(), ce)?;
                    let sym = ast.at(2).unwrap().s_raw();
                    let sym2 = ast.at(3).unwrap().s_raw();

                    Ok(Box::new(move |e: &mut Env| {
                        let m = map(e)?;
                        Ok(m.get_key(&sym).unwrap_or(VVal::Nul)
                            .get_key(&sym2).unwrap_or(VVal::Nul))
                    }))
                },
                Syntax::GetSym3 => {
                    let map = compile(&ast.at(1).unwrap(), ce)?;
                    let sym = ast.at(2).unwrap().s_raw();
                    let sym2 = ast.at(3).unwrap().s_raw();
                    let sym3 = ast.at(4).unwrap().s_raw();

                    Ok(Box::new(move |e: &mut Env| {
                        let m = map(e)?;
                        Ok(m.get_key(&sym).unwrap_or(VVal::Nul)
                            .get_key(&sym2).unwrap_or(VVal::Nul)
                            .get_key(&sym3).unwrap_or(VVal::Nul))
                    }))
                },
                Syntax::GetKey => {
                    let map = compile(&ast.at(1).unwrap(), ce)?;
                    let idx = compile(&ast.at(2).unwrap(), ce)?;
                    Ok(generate_get_key(map, idx, spos, false))
                },
                Syntax::GetKey2 => {
                    let map  = compile(&ast.at(1).unwrap(), ce)?;
                    let idx  = compile(&ast.at(2).unwrap(), ce)?;
                    let idx2 = compile(&ast.at(3).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        let m = map(e)?;
                        let s = check_error_value(idx(e)?, "field idx/key")?;
                        let s2 = check_error_value(idx2(e)?, "field idx/key")?;
                        let m = match s {
                            VVal::Int(i)  => Ok(m.at(i as usize).unwrap_or(VVal::Nul)),
                            VVal::Sym(sy) => Ok(m.get_key(&sy.borrow()).unwrap_or(VVal::Nul)),
                            VVal::Str(sy) => Ok(m.get_key(&sy.borrow()).unwrap_or(VVal::Nul)),
                            _ => {
                                e.push(m.clone());
                                let ret = s.call_internal(e, 1);
                                e.pop();
                                if let Err(sa) = ret {
                                    Err(sa.wrap_panic(Some(spos.clone())))
                                } else {
                                    ret
                                }
                            }
                        }?;
                        match s2 {
                            VVal::Int(i)  => Ok(m.at(i as usize).unwrap_or(VVal::Nul)),
                            VVal::Sym(sy) => Ok(m.get_key(&sy.borrow()).unwrap_or(VVal::Nul)),
                            VVal::Str(sy) => Ok(m.get_key(&sy.borrow()).unwrap_or(VVal::Nul)),
                            _ => {
                                e.push(m.clone());
                                let ret = s2.call_internal(e, 1);
                                e.pop();
                                if let Err(sa) = ret {
                                    Err(sa.wrap_panic(Some(spos.clone())))
                                } else {
                                    ret
                                }
                            }
                        }
                    }))
                },
                Syntax::GetKey3 => {
                    let map  = compile(&ast.at(1).unwrap(), ce)?;
                    let idx  = compile(&ast.at(2).unwrap(), ce)?;
                    let idx2 = compile(&ast.at(3).unwrap(), ce)?;
                    let idx3 = compile(&ast.at(4).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        let m = map(e)?;
                        let s = check_error_value(idx(e)?, "field idx/key")?;
                        let s2 = check_error_value(idx2(e)?, "field idx/key")?;
                        let s3 = check_error_value(idx3(e)?, "field idx/key")?;
                        let m = match s {
                            VVal::Int(i)  => Ok(m.at(i as usize).unwrap_or(VVal::Nul)),
                            VVal::Sym(sy) => Ok(m.get_key(&sy.borrow()).unwrap_or(VVal::Nul)),
                            VVal::Str(sy) => Ok(m.get_key(&sy.borrow()).unwrap_or(VVal::Nul)),
                            _ => {
                                e.push(m.clone());
                                let ret = s.call_internal(e, 1);
                                e.pop();
                                if let Err(sa) = ret {
                                    Err(sa.wrap_panic(Some(spos.clone())))
                                } else {
                                    ret
                                }
                            }
                        }?;
                        let m = match s2 {
                            VVal::Int(i)  => Ok(m.at(i as usize).unwrap_or(VVal::Nul)),
                            VVal::Sym(sy) => Ok(m.get_key(&sy.borrow()).unwrap_or(VVal::Nul)),
                            VVal::Str(sy) => Ok(m.get_key(&sy.borrow()).unwrap_or(VVal::Nul)),
                            _ => {
                                e.push(m.clone());
                                let ret = s2.call_internal(e, 1);
                                e.pop();
                                if let Err(sa) = ret {
                                    Err(sa.wrap_panic(Some(spos.clone())))
                                } else {
                                    ret
                                }
                            }
                        }?;
                        match s3 {
                            VVal::Int(i)  => Ok(m.at(i as usize).unwrap_or(VVal::Nul)),
                            VVal::Sym(sy) => Ok(m.get_key(&sy.borrow()).unwrap_or(VVal::Nul)),
                            VVal::Str(sy) => Ok(m.get_key(&sy.borrow()).unwrap_or(VVal::Nul)),
                            _ => {
                                e.push(m.clone());
                                let ret = s3.call_internal(e, 1);
                                e.pop();
                                if let Err(sa) = ret {
                                    Err(sa.wrap_panic(Some(spos.clone())))
                                } else {
                                    ret
                                }
                            }
                        }
                    }))
                },
                Syntax::SetKey => {
                    let map = compile(&ast.at(1).unwrap(), ce)?;
                    let sym = compile(&ast.at(2).unwrap(), ce)?;
                    let recent_sym = ce.borrow().recent_sym.clone();
                    ce.borrow_mut().recent_var = recent_sym;
                    let val = compile(&ast.at(3).unwrap(), ce)?;
                    Ok(Box::new(move |e: &mut Env| {
                        let m = map(e)?;
                        let s = check_error_value(sym(e)?,
                                                  "field assignment key")?;
                        let v = check_error_value(val(e)?,
                                                  "field assignment value")?;
                        match m.set_key(&s, v.clone()) {
                            Ok(()) => Ok(v),
                            Err(sa) => Err(sa.wrap_panic(Some(spos.clone()))),
                        }
                    }))
                },
                Syntax::CaptureRef => { compile_var(ast, ce, true) },
                Syntax::Ref => {
                    let val = compile(&ast.at(1).unwrap(), ce)?;
                    Ok(Box::new(move |e: &mut Env| {
                        Ok(val(e)?.to_ref())
                    }))
                },
                Syntax::WRef => {
                    let val = compile(&ast.at(1).unwrap(), ce)?;
                    Ok(Box::new(move |e: &mut Env| {
                        Ok(val(e)?.to_weakened_upvalue_ref())
                    }))
                },
                Syntax::Deref => {
                    let val = compile(&ast.at(1).unwrap(), ce)?;
                    Ok(Box::new(move |e: &mut Env| {
                        Ok(val(e)?.deref())
                    }))
                },
                Syntax::Lst => {
                    let list_elems : Vec<(bool, EvalNode)> =
                        ast.map_skip(|e| {
                            if e.is_vec() {
                                if let VVal::Syn(SynPos { syn: Syntax::VecSplice, .. }) =
                                    e.at(0).unwrap_or(VVal::Nul)
                                {
                                    return Ok((true, compile(&e.at(1).unwrap(), ce)?));
                                }
                            }
                            Ok((false, compile(e, ce)?))
                        }, 1)?;

                    Ok(Box::new(move |e: &mut Env| {
                        let v = VVal::vec();
                        for (is_splice, x) in list_elems.iter() {
                            let av = check_error_value(x(e)?, "list")?;
                            if *is_splice {
                                av.for_each(|e| { v.push(e.clone()); });
                            } else {
                                v.push(av);
                            }
                        }
                        Ok(v)
                    }))
                },
                Syntax::Map    => {
                    let map_elems : Result<Vec<(EvalNode,Option<EvalNode>)>, CompileError> =
                        ast.map_skip(|e| {
                                let k = e.at(0).unwrap();
                                let v = e.at(1).unwrap();
                                if let VVal::Syn(SynPos { syn: Syntax::MapSplice, .. }) = k {
                                    let sc = compile(&v, ce)?;
                                    Ok((sc, None))
                                } else {
                                    let kc = compile(&k, ce)?;
                                    if let VVal::Sym(y) = k {
                                        ce.borrow_mut().recent_var = y.borrow().clone();
                                    } else {
                                        let recent_sym = ce.borrow().recent_sym.clone();
                                        ce.borrow_mut().recent_var = recent_sym;
                                    }
                                    let vc = compile(&v, ce)?;
                                    Ok((kc, Some(vc)))
                                }
                            }, 1);
                    if let Err(e) = map_elems { return Err(e); }
                    let map_elems = map_elems.unwrap();

                    Ok(Box::new(move |e: &mut Env| {
                        let v = VVal::map();
                        for x in map_elems.iter() {
                            let ke = check_error_value(x.0(e)?, "map key")?;
                            if let Some(ref kv) = x.1 {
                                let kv = check_error_value(kv(e)?, "map value")?;
                                v.set_key(&ke, kv).unwrap();
                            } else {
                                let splice_map = ke;
                                splice_map.for_eachk(|sk, sv| {
                                    v.set_key_mv(sk.to_string(), sv.clone());
                                });
                            }
                        }
                        Ok(v)
                    }))
                },
                Syntax::Or => {
                    let exprs : Vec<EvalNode> =
                        ast.map_skip(|e| compile(e, ce), 1)?;

                    Ok(Box::new(move |e: &mut Env| {
                        for x in exprs.iter() {
                            let ret = x(e)?;
                            if ret.b() {
                                return Ok(ret);
                            }
                        }
                        Ok(VVal::Bol(false))
                    }))
                },
                Syntax::And => {
                    let exprs : Vec<EvalNode> =
                        ast.map_skip(|e| compile(e, ce), 1)?;

                    Ok(Box::new(move |e: &mut Env| {
                        let mut ret = VVal::Nul;
                        for x in exprs.iter() {
                            ret = x(e)?;
                            if !ret.b() {
                                return Ok(VVal::Bol(false));
                            }
                        }
                        Ok(ret)
                    }))
                },
                Syntax::Apply => {
                    let call_argv = compile(&ast.at(2).unwrap(), ce)?;
                    let func      = compile(&ast.at(1).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        let f = func(e)?;
                        let mut argv = call_argv(e)?;
                        let argc =
                            if let VVal::Lst(l) = &argv {
                                l.borrow().len()
                            } else {
                                let a = VVal::vec();
                                a.push(argv);
                                argv = a;
                                1
                            };

                        for i in 0..argc {
                            let v = argv.at(i).unwrap_or(VVal::Nul);
                            e.push(v);
                        }

                        let ret = f.call_internal(e, argc);
                        e.popn(argc);
                        if let Err(sa) = ret {
                            Err(sa.wrap_panic(Some(spos.clone())))
                        } else {
                            ret
                        }
                    }))
                },
                Syntax::BinOpAdd => {
                    let left  = compile(&ast.at(1).unwrap(), ce)?;
                    let right = compile(&ast.at(2).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        Ok(match (left(e)?, right(e)?) {
                            (VVal::IVec(ln), re) => VVal::IVec(ln + re.nvec()),
                            (VVal::FVec(ln), re) => VVal::FVec(ln + re.nvec()),
                            (VVal::Flt(f), re)   => VVal::Flt(f + re.f()),
                            (le, re)             => VVal::Int(le.i().wrapping_add(re.i()))
                        })
                    }))
                },
                Syntax::BinOpSub => {
                    let left  = compile(&ast.at(1).unwrap(), ce)?;
                    let right = compile(&ast.at(2).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        Ok(match (left(e)?, right(e)?) {
                            (VVal::IVec(ln), re) => VVal::IVec(ln - re.nvec()),
                            (VVal::FVec(ln), re) => VVal::FVec(ln - re.nvec()),
                            (VVal::Flt(f), re)   => VVal::Flt(f - re.f()),
                            (le, re)             => VVal::Int(le.i().wrapping_sub(re.i()))
                        })
                    }))
                },
                Syntax::BinOpMul => {
                    let left  = compile(&ast.at(1).unwrap(), ce)?;
                    let right = compile(&ast.at(2).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        Ok(match (left(e)?, right(e)?) {
                            (VVal::IVec(ln), re) => VVal::IVec(ln * re.i()),
                            (VVal::FVec(ln), re) => VVal::FVec(ln * re.f()),
                            (VVal::Flt(f),   re) => VVal::Flt(f   * re.f()),
                            (le, re)             => VVal::Int(le.i().wrapping_mul(re.i()))
                        })
                    }))
                },
                Syntax::BinOpDiv => {
                    let left  = compile(&ast.at(1).unwrap(), ce)?;
                    let right = compile(&ast.at(2).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        Ok(match (left(e)?, right(e)?) {
                            (VVal::IVec(ln), re) => VVal::IVec(ln / re.i()),
                            (VVal::FVec(ln), re) => VVal::FVec(ln / re.f()),
                            (VVal::Flt(f),   re) => VVal::Flt(f   / re.f()),
                            (le, VVal::Int(0))   => return Err(StackAction::panic_str(
                                    format!("Division by 0: {}/{}", le.i(), 0),
                                    Some(spos.clone())
                                )),
                            (le, re)             => VVal::Int(le.i().wrapping_div(re.i()))
                        })
                    }))
                },
                Syntax::BinOpMod => {
                    let left  = compile(&ast.at(1).unwrap(), ce)?;
                    let right = compile(&ast.at(2).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        let le = left(e)?;
                        let re = right(e)?;
                        if let VVal::Flt(f) = le {
                            Ok(VVal::Flt(f % re.f()))
                        } else {
                            Ok(VVal::Int(le.i().wrapping_rem(re.i())))
                        }
                    }))
                },
                Syntax::BinOpLe => {
                    let left  = compile(&ast.at(1).unwrap(), ce)?;
                    let right = compile(&ast.at(2).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        let le = left(e)?;
                        let re = right(e)?;
                        if let VVal::Flt(af) = le {
                            Ok(VVal::Bol(af <= re.f()))
                        } else {
                            Ok(VVal::Bol(le.i() <= re.i()))
                        }
                    }))
                },
                Syntax::BinOpGe => {
                    let left  = compile(&ast.at(1).unwrap(), ce)?;
                    let right = compile(&ast.at(2).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        let le = left(e)?;
                        let re = right(e)?;
                        if let VVal::Flt(af) = le {
                            Ok(VVal::Bol(af >= re.f()))
                        } else {
                            Ok(VVal::Bol(le.i() >= re.i()))
                        }
                    }))
                },
                Syntax::BinOpLt => {
                    let left  = compile(&ast.at(1).unwrap(), ce)?;
                    let right = compile(&ast.at(2).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        let le = left(e)?;
                        let re = right(e)?;
                        if let VVal::Flt(af) = le {
                            Ok(VVal::Bol(af < re.f()))
                        } else {
                            Ok(VVal::Bol(le.i() < re.i()))
                        }
                    }))
                },
                Syntax::BinOpGt => {
                    let left  = compile(&ast.at(1).unwrap(), ce)?;
                    let right = compile(&ast.at(2).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        let le = left(e)?;
                        let re = right(e)?;
                        if let VVal::Flt(af) = le {
                            Ok(VVal::Bol(af > re.f()))
                        } else {
                            Ok(VVal::Bol(le.i() > re.i()))
                        }
                    }))
                },
                Syntax::BinOpEq => {
                    let left  = compile(&ast.at(1).unwrap(), ce)?;
                    let right = compile(&ast.at(2).unwrap(), ce)?;

                    Ok(Box::new(move |e: &mut Env| {
                        let le = left(e)?;
                        let re = right(e)?;
                        Ok(VVal::Bol(le.eqv(&re)))
                    }))
                },
                Syntax::Call => {
                    if let Some((syntax, object, key)) =
                        fetch_object_key_access(&ast.at(1).unwrap()) {

                        let call_args : Vec<EvalNode> =
                            ast.map_skip(|e| compile(e, ce), 2)?;

                        let obj = compile(&object, ce)?;

                        match syntax {
                            Syntax::GetKey => {
                                let key = compile(&key, ce)?;
                                let func = generate_get_key(
                                    Box::new(move |e: &mut Env| Ok(e.self_object())),
                                    key,
                                    spos.clone(),
                                    true);
                                let fun_call =
                                    generate_call(func, call_args, spos);
                                Ok(Box::new(move |e: &mut Env| {
                                    let o = obj(e)?;
                                    e.with_object(
                                        o, |e: &mut Env| fun_call(e))
                                }))
                            },
                            Syntax::GetSym => {
                                let key = key.s_raw();
                                let func = Box::new(move |e: &mut Env| {
                                    let o = e.self_object();
                                    Ok(o.proto_lookup(&key).unwrap_or(VVal::Nul))
                                });
                                let fun_call =
                                    generate_call(func, call_args, spos);
                                Ok(Box::new(move |e: &mut Env| {
                                    let o = obj(e)?;
                                    e.with_object(
                                        o, |e: &mut Env| fun_call(e))
                                }))
                            },
                            _ => {
                                ast.to_compile_err(
                                    format!("fetch_object_key_access failed: {}",
                                            ast.s()))
                            },
                        }

                    } else {
                        let is_if =
                            if let Syntax::Var = ast.at(1).unwrap_or(VVal::Nul).at(0).unwrap_or(VVal::Nul).get_syn() {
                                let var = ast.at(1).unwrap().at(1).unwrap();
                                var.with_s_ref(|var_s: &str| var_s == "?")
                            } else {
                                false
                            };

                        if is_if {
                            if ast.len() > 5 {
                                return ast.to_compile_err(
                                    format!("if can only have 2 arguments, got more: {}", ast.s()));
                            }
                            ce.borrow_mut().quote_func = true;
                            let cond = compile_block_env(&ast.at(2).unwrap_or(VVal::Nul), ce)?;
                            ce.borrow_mut().quote_func = true;
                            let then = compile_block_env(&ast.at(3).unwrap_or(VVal::Nul), ce)?;
                            ce.borrow_mut().quote_func = true;
                            let els  = compile_block_env(&ast.at(4).unwrap_or(VVal::Nul), ce)?;

                            Ok(Box::new(move |e: &mut Env| {
                                if cond(e)?.b() {
                                    then(e)
                                } else {
                                    els(e)
                                }
                            }))

                        } else {
                            let mut call_args : Vec<EvalNode> =
                                ast.map_skip(|e| compile(e, ce), 1)?;
                            call_args.reverse();
                            let func = call_args.pop().expect("function in evaluation args list");
                            call_args.reverse();

                            Ok(generate_call(func, call_args, spos))
                        }
                    }
                },
                Syntax::Func => {
                    let last_def_varname = ce.borrow().recent_var.clone();
                    let mut fun_spos = spos;
                    fun_spos.name = Some(Rc::new(last_def_varname));

                    let cur_ce = ce.clone();
                    let func_ce = CompileEnv::create_env(Some(ce.clone()));

                    let mut ce_sub =
                        if quote_func {
                            cur_ce
                        } else {
                            func_ce
                        };

                    let label          = ast.at(1).unwrap();
                    let explicit_arity = ast.at(2).unwrap();
                    let stmts : Vec<EvalNode> =
                        ast.map_skip(|e| compile(e, &mut ce_sub), 3)?;

                    let spos_inner = fun_spos.clone();
                    #[allow(unused_assignments)]
                    let fun_ref = Rc::new(RefCell::new(move |env: &mut Env, _argc: usize| {
                        let mut res = VVal::Nul;
                        for s in stmts.iter() {
                            if let VVal::Err(ev) = res {
                                return
                                    Err(StackAction::panic_str(
                                        format!("Error value '{}' dropped.",
                                                ev.borrow().0.s()),
                                        Some(ev.borrow().1.clone())));
                            }

                            res = VVal::Nul; // drop any previous value now.
                            match s(env) {
                                Ok(v)  => { res = v; },
                                Err(StackAction::Return((v_lbl, v))) => {
                                    return
                                        if v_lbl.eqv(&label) { Ok(v) }
                                        else { Err(StackAction::Return((v_lbl, v))) }
                                },
                                Err(e) => { return Err(e.wrap_panic(Some(spos_inner.clone()))) }
                            }
                        }
                        Ok(res)
                    }));

                    ce_sub.borrow_mut().explicit_arity.0 =
                        match explicit_arity.at(0).unwrap_or(VVal::Nul) {
                            VVal::Int(i) => ArityParam::Limit(i as usize),
                            VVal::Bol(true) => ArityParam::Limit(0),
                            _ => ArityParam::Undefined,
                        };

                    ce_sub.borrow_mut().explicit_arity.1 =
                        match explicit_arity.at(1).unwrap_or(VVal::Nul) {
                            VVal::Int(i) => ArityParam::Limit(i as usize),
                            VVal::Bol(true) => ArityParam::Infinite,
                            _ => ArityParam::Undefined,
                        };

                    let deciding_min_arity = if ce_sub.borrow().explicit_arity.0 != ArityParam::Undefined {
                        ce_sub.borrow().explicit_arity.0.clone()
                    } else {
                        ce_sub.borrow().implicit_arity.0.clone()
                    };

                    let deciding_max_arity = if ce_sub.borrow().explicit_arity.1 != ArityParam::Undefined {
                        ce_sub.borrow().explicit_arity.1.clone()
                    } else {
                        ce_sub.borrow().implicit_arity.1.clone()
                    };

                    let min_args : Option<usize> = match deciding_min_arity {
                        ArityParam::Infinite  => None,
                        ArityParam::Undefined => Some(0),
                        ArityParam::Limit(i)  => Some(i),
                    };

                    let max_args : Option<usize> = match deciding_max_arity {
                        ArityParam::Infinite  => None,
                        ArityParam::Undefined => Some(0),
                        ArityParam::Limit(i)  => Some(i),
                    };

                    let env_size = ce_sub.borrow().local_env_size();
                    if quote_func {
                        Ok(Box::new(move |e: &mut Env| {
                            let r = fun_ref.borrow();
                            let r = r(e, 0);
                            r
                        }))
                    } else {
                        let upvs = ce_sub.borrow_mut().get_upval_pos();
                        let fun =
                            VValFun::new_val(
                                fun_ref.clone(),
                                vec![], env_size, min_args, max_args, false,
                                Some(fun_spos.clone()),
                                Rc::new(upvs));
                        Ok(Box::new(move |e: &mut Env| {
                            Ok(fun.clone_and_rebind_upvalues(|upvs, upvalues| {
                                copy_upvs(upvs, e, upvalues);
                            }))
                        }))
                    }
                },
                _ => { ast.to_compile_err(format!("bad input: {}", ast.s())) }
            }
        },
        VVal::Pair(bx) => {
            let a = compile(&bx.0, ce)?;
            let b = compile(&bx.1, ce)?;
            Ok(Box::new(move |e: &mut Env| {
                Ok(VVal::Pair(Box::new((a(e)?, b(e)?))))
            }))

        },
        _ => {
            let am = ast.clone();
            Ok(Box::new(move |_e: &mut Env| Ok(am.clone())))
        }
    }
}

/// Evaluates a piece of WLambda code in a default global environment.
///
/// ```
/// println!("> {}", wlambda::eval("${a = 10, b = 20}").unwrap().s());
/// ```
#[allow(dead_code)]
pub fn eval(s: &str) -> Result<VVal, EvalError>  {
    let mut ctx = EvalContext::new_default();
    ctx.eval(s)
}
